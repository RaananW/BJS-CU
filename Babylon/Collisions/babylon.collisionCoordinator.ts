module BABYLON {

    export var CollisionWorker = 'window = {};\n\nvar BABYLON;\n(function (BABYLON) {\n    var intersectBoxAASphere = function (boxMin, boxMax, sphereCenter, sphereRadius) {\n        if (boxMin.x > sphereCenter.x + sphereRadius)\n            return false;\n        if (sphereCenter.x - sphereRadius > boxMax.x)\n            return false;\n        if (boxMin.y > sphereCenter.y + sphereRadius)\n            return false;\n        if (sphereCenter.y - sphereRadius > boxMax.y)\n            return false;\n        if (boxMin.z > sphereCenter.z + sphereRadius)\n            return false;\n        if (sphereCenter.z - sphereRadius > boxMax.z)\n            return false;\n        return true;\n    };\n    var getLowestRoot = function (a, b, c, maxR) {\n        var determinant = b * b - 4.0 * a * c;\n        var result = { root: 0, found: false };\n        if (determinant < 0)\n            return result;\n        var sqrtD = Math.sqrt(determinant);\n        var r1 = (-b - sqrtD) \/ (2.0 * a);\n        var r2 = (-b + sqrtD) \/ (2.0 * a);\n        if (r1 > r2) {\n            var temp = r2;\n            r2 = r1;\n            r1 = temp;\n        }\n        if (r1 > 0 && r1 < maxR) {\n            result.root = r1;\n            result.found = true;\n            return result;\n        }\n        if (r2 > 0 && r2 < maxR) {\n            result.root = r2;\n            result.found = true;\n            return result;\n        }\n        return result;\n    };\n    var Collider = (function () {\n        function Collider() {\n            this.radius = new BABYLON.Vector3(1, 1, 1);\n            this.retry = 0;\n            this.basePointWorld = BABYLON.Vector3.Zero();\n            this.velocityWorld = BABYLON.Vector3.Zero();\n            this.normalizedVelocity = BABYLON.Vector3.Zero();\n            this._collisionPoint = BABYLON.Vector3.Zero();\n            this._planeIntersectionPoint = BABYLON.Vector3.Zero();\n            this._tempVector = BABYLON.Vector3.Zero();\n            this._tempVector2 = BABYLON.Vector3.Zero();\n            this._tempVector3 = BABYLON.Vector3.Zero();\n            this._tempVector4 = BABYLON.Vector3.Zero();\n            this._edge = BABYLON.Vector3.Zero();\n            this._baseToVertex = BABYLON.Vector3.Zero();\n            this._destinationPoint = BABYLON.Vector3.Zero();\n            this._slidePlaneNormal = BABYLON.Vector3.Zero();\n            this._displacementVector = BABYLON.Vector3.Zero();\n        }\n        \/\/ Methods\n        Collider.prototype._initialize = function (source, dir, e) {\n            this.velocity = dir;\n            BABYLON.Vector3.NormalizeToRef(dir, this.normalizedVelocity);\n            this.basePoint = source;\n            source.multiplyToRef(this.radius, this.basePointWorld);\n            dir.multiplyToRef(this.radius, this.velocityWorld);\n            this.velocityWorldLength = this.velocityWorld.length();\n            this.epsilon = e;\n            this.collisionFound = false;\n        };\n        Collider.prototype._checkPointInTriangle = function (point, pa, pb, pc, n) {\n            pa.subtractToRef(point, this._tempVector);\n            pb.subtractToRef(point, this._tempVector2);\n            BABYLON.Vector3.CrossToRef(this._tempVector, this._tempVector2, this._tempVector4);\n            var d = BABYLON.Vector3.Dot(this._tempVector4, n);\n            if (d < 0)\n                return false;\n            pc.subtractToRef(point, this._tempVector3);\n            BABYLON.Vector3.CrossToRef(this._tempVector2, this._tempVector3, this._tempVector4);\n            d = BABYLON.Vector3.Dot(this._tempVector4, n);\n            if (d < 0)\n                return false;\n            BABYLON.Vector3.CrossToRef(this._tempVector3, this._tempVector, this._tempVector4);\n            d = BABYLON.Vector3.Dot(this._tempVector4, n);\n            return d >= 0;\n        };\n        Collider.prototype._canDoCollision = function (sphereCenter, sphereRadius, vecMin, vecMax) {\n            var distance = BABYLON.Vector3.Distance(this.basePointWorld, sphereCenter);\n            var max = Math.max(this.radius.x, this.radius.y, this.radius.z);\n            if (distance > this.velocityWorldLength + max + sphereRadius) {\n                return false;\n            }\n            if (!intersectBoxAASphere(vecMin, vecMax, this.basePointWorld, this.velocityWorldLength + max))\n                return false;\n            return true;\n        };\n        Collider.prototype._testTriangle = function (faceIndex, trianglePlaneArray, p1, p2, p3, hasMaterial) {\n            var t0;\n            var embeddedInPlane = false;\n            \/\/defensive programming, actually not needed.\n            if (!trianglePlaneArray) {\n                trianglePlaneArray = [];\n            }\n            if (!trianglePlaneArray[faceIndex]) {\n                trianglePlaneArray[faceIndex] = new BABYLON.Plane(0, 0, 0, 0);\n                trianglePlaneArray[faceIndex].copyFromPoints(p1, p2, p3);\n            }\n            var trianglePlane = trianglePlaneArray[faceIndex];\n            if ((!hasMaterial) && !trianglePlane.isFrontFacingTo(this.normalizedVelocity, 0))\n                return;\n            var signedDistToTrianglePlane = trianglePlane.signedDistanceTo(this.basePoint);\n            var normalDotVelocity = BABYLON.Vector3.Dot(trianglePlane.normal, this.velocity);\n            if (normalDotVelocity == 0) {\n                if (Math.abs(signedDistToTrianglePlane) >= 1.0)\n                    return;\n                embeddedInPlane = true;\n                t0 = 0;\n            }\n            else {\n                t0 = (-1.0 - signedDistToTrianglePlane) \/ normalDotVelocity;\n                var t1 = (1.0 - signedDistToTrianglePlane) \/ normalDotVelocity;\n                if (t0 > t1) {\n                    var temp = t1;\n                    t1 = t0;\n                    t0 = temp;\n                }\n                if (t0 > 1.0 || t1 < 0.0)\n                    return;\n                if (t0 < 0)\n                    t0 = 0;\n                if (t0 > 1.0)\n                    t0 = 1.0;\n            }\n            this._collisionPoint.copyFromFloats(0, 0, 0);\n            var found = false;\n            var t = 1.0;\n            if (!embeddedInPlane) {\n                this.basePoint.subtractToRef(trianglePlane.normal, this._planeIntersectionPoint);\n                this.velocity.scaleToRef(t0, this._tempVector);\n                this._planeIntersectionPoint.addInPlace(this._tempVector);\n                if (this._checkPointInTriangle(this._planeIntersectionPoint, p1, p2, p3, trianglePlane.normal)) {\n                    found = true;\n                    t = t0;\n                    this._collisionPoint.copyFrom(this._planeIntersectionPoint);\n                }\n            }\n            if (!found) {\n                var velocitySquaredLength = this.velocity.lengthSquared();\n                var a = velocitySquaredLength;\n                this.basePoint.subtractToRef(p1, this._tempVector);\n                var b = 2.0 * (BABYLON.Vector3.Dot(this.velocity, this._tempVector));\n                var c = this._tempVector.lengthSquared() - 1.0;\n                var lowestRoot = getLowestRoot(a, b, c, t);\n                if (lowestRoot.found) {\n                    t = lowestRoot.root;\n                    found = true;\n                    this._collisionPoint.copyFrom(p1);\n                }\n                this.basePoint.subtractToRef(p2, this._tempVector);\n                b = 2.0 * (BABYLON.Vector3.Dot(this.velocity, this._tempVector));\n                c = this._tempVector.lengthSquared() - 1.0;\n                lowestRoot = getLowestRoot(a, b, c, t);\n                if (lowestRoot.found) {\n                    t = lowestRoot.root;\n                    found = true;\n                    this._collisionPoint.copyFrom(p2);\n                }\n                this.basePoint.subtractToRef(p3, this._tempVector);\n                b = 2.0 * (BABYLON.Vector3.Dot(this.velocity, this._tempVector));\n                c = this._tempVector.lengthSquared() - 1.0;\n                lowestRoot = getLowestRoot(a, b, c, t);\n                if (lowestRoot.found) {\n                    t = lowestRoot.root;\n                    found = true;\n                    this._collisionPoint.copyFrom(p3);\n                }\n                p2.subtractToRef(p1, this._edge);\n                p1.subtractToRef(this.basePoint, this._baseToVertex);\n                var edgeSquaredLength = this._edge.lengthSquared();\n                var edgeDotVelocity = BABYLON.Vector3.Dot(this._edge, this.velocity);\n                var edgeDotBaseToVertex = BABYLON.Vector3.Dot(this._edge, this._baseToVertex);\n                a = edgeSquaredLength * (-velocitySquaredLength) + edgeDotVelocity * edgeDotVelocity;\n                b = edgeSquaredLength * (2.0 * BABYLON.Vector3.Dot(this.velocity, this._baseToVertex)) - 2.0 * edgeDotVelocity * edgeDotBaseToVertex;\n                c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n                lowestRoot = getLowestRoot(a, b, c, t);\n                if (lowestRoot.found) {\n                    var f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) \/ edgeSquaredLength;\n                    if (f >= 0.0 && f <= 1.0) {\n                        t = lowestRoot.root;\n                        found = true;\n                        this._edge.scaleInPlace(f);\n                        p1.addToRef(this._edge, this._collisionPoint);\n                    }\n                }\n                p3.subtractToRef(p2, this._edge);\n                p2.subtractToRef(this.basePoint, this._baseToVertex);\n                edgeSquaredLength = this._edge.lengthSquared();\n                edgeDotVelocity = BABYLON.Vector3.Dot(this._edge, this.velocity);\n                edgeDotBaseToVertex = BABYLON.Vector3.Dot(this._edge, this._baseToVertex);\n                a = edgeSquaredLength * (-velocitySquaredLength) + edgeDotVelocity * edgeDotVelocity;\n                b = edgeSquaredLength * (2.0 * BABYLON.Vector3.Dot(this.velocity, this._baseToVertex)) - 2.0 * edgeDotVelocity * edgeDotBaseToVertex;\n                c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n                lowestRoot = getLowestRoot(a, b, c, t);\n                if (lowestRoot.found) {\n                    f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) \/ edgeSquaredLength;\n                    if (f >= 0.0 && f <= 1.0) {\n                        t = lowestRoot.root;\n                        found = true;\n                        this._edge.scaleInPlace(f);\n                        p2.addToRef(this._edge, this._collisionPoint);\n                    }\n                }\n                p1.subtractToRef(p3, this._edge);\n                p3.subtractToRef(this.basePoint, this._baseToVertex);\n                edgeSquaredLength = this._edge.lengthSquared();\n                edgeDotVelocity = BABYLON.Vector3.Dot(this._edge, this.velocity);\n                edgeDotBaseToVertex = BABYLON.Vector3.Dot(this._edge, this._baseToVertex);\n                a = edgeSquaredLength * (-velocitySquaredLength) + edgeDotVelocity * edgeDotVelocity;\n                b = edgeSquaredLength * (2.0 * BABYLON.Vector3.Dot(this.velocity, this._baseToVertex)) - 2.0 * edgeDotVelocity * edgeDotBaseToVertex;\n                c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n                lowestRoot = getLowestRoot(a, b, c, t);\n                if (lowestRoot.found) {\n                    f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) \/ edgeSquaredLength;\n                    if (f >= 0.0 && f <= 1.0) {\n                        t = lowestRoot.root;\n                        found = true;\n                        this._edge.scaleInPlace(f);\n                        p3.addToRef(this._edge, this._collisionPoint);\n                    }\n                }\n            }\n            if (found) {\n                var distToCollision = t * this.velocity.length();\n                if (!this.collisionFound || distToCollision < this.nearestDistance) {\n                    if (!this.intersectionPoint) {\n                        this.intersectionPoint = this._collisionPoint.clone();\n                    }\n                    else {\n                        this.intersectionPoint.copyFrom(this._collisionPoint);\n                    }\n                    this.nearestDistance = distToCollision;\n                    this.collisionFound = true;\n                }\n            }\n        };\n        Collider.prototype._collide = function (trianglePlaneArray, pts, indices, indexStart, indexEnd, decal, hasMaterial) {\n            for (var i = indexStart; i < indexEnd; i += 3) {\n                var p1 = pts[indices[i] - decal];\n                var p2 = pts[indices[i + 1] - decal];\n                var p3 = pts[indices[i + 2] - decal];\n                this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial);\n            }\n        };\n        Collider.prototype._getResponse = function (pos, vel) {\n            pos.addToRef(vel, this._destinationPoint);\n            vel.scaleInPlace((this.nearestDistance \/ vel.length()));\n            this.basePoint.addToRef(vel, pos);\n            pos.subtractToRef(this.intersectionPoint, this._slidePlaneNormal);\n            this._slidePlaneNormal.normalize();\n            this._slidePlaneNormal.scaleToRef(this.epsilon, this._displacementVector);\n            pos.addInPlace(this._displacementVector);\n            this.intersectionPoint.addInPlace(this._displacementVector);\n            this._slidePlaneNormal.scaleInPlace(BABYLON.Plane.SignedDistanceToPlaneFromPositionAndNormal(this.intersectionPoint, this._slidePlaneNormal, this._destinationPoint));\n            this._destinationPoint.subtractInPlace(this._slidePlaneNormal);\n            this._destinationPoint.subtractToRef(this.intersectionPoint, vel);\n        };\n        return Collider;\n    })();\n    BABYLON.Collider = Collider;\n})(BABYLON || (BABYLON = {}));\n\nvar BABYLON;\n(function (BABYLON) {\n    var CollisionCache = (function () {\n        function CollisionCache() {\n            this._meshes = {};\n            this._geometries = {};\n        }\n        CollisionCache.prototype.getMeshes = function () {\n            return this._meshes;\n        };\n        CollisionCache.prototype.getGeometries = function () {\n            return this._geometries;\n        };\n        CollisionCache.prototype.getMesh = function (id) {\n            return this._meshes[id];\n        };\n        CollisionCache.prototype.addMesh = function (mesh) {\n            this._meshes[mesh.uniqueId] = mesh;\n        };\n        CollisionCache.prototype.getGeometry = function (id) {\n            return this._geometries[id];\n        };\n        CollisionCache.prototype.addGeometry = function (geometry) {\n            this._geometries[geometry.id] = geometry;\n        };\n        return CollisionCache;\n    })();\n    BABYLON.CollisionCache = CollisionCache;\n    var CollideWorker = (function () {\n        function CollideWorker(collider, _collisionCache, finalPosition) {\n            this.collider = collider;\n            this._collisionCache = _collisionCache;\n            this.finalPosition = finalPosition;\n            this.collisionsScalingMatrix = BABYLON.Matrix.Zero();\n            this.collisionTranformationMatrix = BABYLON.Matrix.Zero();\n        }\n        CollideWorker.prototype.collideWithWorld = function (position, velocity, maximumRetry, excludedMeshUniqueId) {\n            var closeDistance = BABYLON.Engine.CollisionsEpsilon * 10.0;\n            \/\/is initializing here correct? A quick look - looks like it is fine.\n            if (this.collider.retry >= maximumRetry) {\n                this.finalPosition.copyFrom(position);\n                return;\n            }\n            this.collider._initialize(position, velocity, closeDistance);\n            \/\/ Check all meshes\n            var meshes = this._collisionCache.getMeshes();\n            for (var uniqueId in meshes) {\n                if (meshes.hasOwnProperty(uniqueId) && parseInt(uniqueId) != excludedMeshUniqueId) {\n                    var mesh = meshes[uniqueId];\n                    if (mesh.checkCollisions)\n                        this.checkCollision(mesh);\n                }\n            }\n            if (!this.collider.collisionFound) {\n                position.addToRef(velocity, this.finalPosition);\n                return;\n            }\n            if (velocity.x !== 0 || velocity.y !== 0 || velocity.z !== 0) {\n                this.collider._getResponse(position, velocity);\n            }\n            if (velocity.length() <= closeDistance) {\n                \/\/console.log(\"webworker collision with \" + this.collider.collidedMesh);\n                this.finalPosition.copyFrom(position);\n                return;\n            }\n            this.collider.retry++;\n            this.collideWithWorld(position, velocity, maximumRetry, excludedMeshUniqueId);\n        };\n        CollideWorker.prototype.checkCollision = function (mesh) {\n            if (!this.collider._canDoCollision(BABYLON.Vector3.FromArray(mesh.sphereCenter), mesh.sphereRadius, BABYLON.Vector3.FromArray(mesh.boxMinimum), BABYLON.Vector3.FromArray(mesh.boxMaximum))) {\n                return;\n            }\n            ;\n            \/\/ Transformation matrix\n            BABYLON.Matrix.ScalingToRef(1.0 \/ this.collider.radius.x, 1.0 \/ this.collider.radius.y, 1.0 \/ this.collider.radius.z, this.collisionsScalingMatrix);\n            var worldFromCache = BABYLON.Matrix.FromArray(mesh.worldMatrixFromCache);\n            worldFromCache.multiplyToRef(this.collisionsScalingMatrix, this.collisionTranformationMatrix);\n            this.processCollisionsForSubMeshes(this.collisionTranformationMatrix, mesh);\n            \/\/return colTransMat;\n        };\n        CollideWorker.prototype.processCollisionsForSubMeshes = function (transformMatrix, mesh) {\n            var len;\n            \/\/ No Octrees for now\n            \/\/if (this._submeshesOctree && this.useOctreeForCollisions) {\n            \/\/    var radius = collider.velocityWorldLength + Math.max(collider.radius.x, collider.radius.y, collider.radius.z);\n            \/\/    var intersections = this._submeshesOctree.intersects(collider.basePointWorld, radius);\n            \/\/    len = intersections.length;\n            \/\/    subMeshes = intersections.data;\n            \/\/} else {\n            \/\/    subMeshes = this.subMeshes;\n            \/\/    len = subMeshes.length;\n            \/\/}\n            if (!mesh.geometryId) {\n                console.log(\"no mesh geometry id\");\n                return;\n            }\n            var meshGeometry = this._collisionCache.getGeometry(mesh.geometryId);\n            if (!meshGeometry) {\n                console.log(\"couldn\'t find geometry\", mesh.geometryId);\n                return;\n            }\n            for (var index = 0; index < mesh.subMeshes.length; index++) {\n                var subMesh = mesh.subMeshes[index];\n                \/\/ Bounding test\n                if (len > 1 && !this.checkSubmeshCollision(subMesh))\n                    continue;\n                subMesh[\'getMesh\'] = function () {\n                    return mesh.uniqueId;\n                };\n                this.collideForSubMesh(subMesh, transformMatrix, meshGeometry);\n            }\n        };\n        CollideWorker.prototype.collideForSubMesh = function (subMesh, transformMatrix, meshGeometry) {\n            var positionsArray = [];\n            for (var i = 0; i < meshGeometry.positions.length; i = i + 3) {\n                var p = BABYLON.Vector3.FromArray([meshGeometry.positions[i], meshGeometry.positions[i + 1], meshGeometry.positions[i + 2]]);\n                positionsArray.push(p);\n            }\n            subMesh[\'_lastColliderTransformMatrix\'] = transformMatrix.clone();\n            subMesh[\'_lastColliderWorldVertices\'] = [];\n            subMesh[\'_trianglePlanes\'] = [];\n            var start = subMesh.verticesStart;\n            var end = (subMesh.verticesStart + subMesh.verticesCount);\n            for (var i = start; i < end; i++) {\n                subMesh[\'_lastColliderWorldVertices\'].push(BABYLON.Vector3.TransformCoordinates(positionsArray[i], transformMatrix));\n            }\n            \/\/}\n            \/\/ Collide\n            this.collider._collide([], subMesh[\'_lastColliderWorldVertices\'], meshGeometry.indices, subMesh.indexStart, subMesh.indexStart + subMesh.indexCount, subMesh.verticesStart, subMesh.hasMaterial);\n        };\n        \/\/TODO - this! :-)\n        CollideWorker.prototype.checkSubmeshCollision = function (subMesh) {\n            return true;\n        };\n        return CollideWorker;\n    })();\n    BABYLON.CollideWorker = CollideWorker;\n    var CollisionDetectorTransferable = (function () {\n        function CollisionDetectorTransferable() {\n        }\n        CollisionDetectorTransferable.prototype.onInit = function (payload) {\n            this._collisionCache = new CollisionCache();\n            var reply = {\n                error: BABYLON.WorkerReplyType.SUCCESS,\n                taskType: BABYLON.WorkerTaskType.INIT\n            };\n            postMessage(reply, undefined);\n        };\n        CollisionDetectorTransferable.prototype.onUpdate = function (payload) {\n            for (var id in payload.updatedGeometries) {\n                if (payload.updatedGeometries.hasOwnProperty(id)) {\n                    this._collisionCache.addGeometry(payload.updatedGeometries[id]);\n                }\n            }\n            for (var uniqueId in payload.updatedMeshes) {\n                if (payload.updatedMeshes.hasOwnProperty(uniqueId)) {\n                    this._collisionCache.addMesh(payload.updatedMeshes[uniqueId]);\n                }\n            }\n            var replay = {\n                error: BABYLON.WorkerReplyType.SUCCESS,\n                taskType: BABYLON.WorkerTaskType.UPDATE\n            };\n            console.log(\"updated\");\n            postMessage(replay, undefined);\n        };\n        CollisionDetectorTransferable.prototype.onCollision = function (payload) {\n            var finalPosition = BABYLON.Vector3.Zero();\n            \/\/create a new collider\n            var collider = new BABYLON.Collider();\n            collider.radius = BABYLON.Vector3.FromArray(payload.collider.radius);\n            var colliderWorker = new CollideWorker(collider, this._collisionCache, finalPosition);\n            colliderWorker.collideWithWorld(BABYLON.Vector3.FromArray(payload.collider.position), BABYLON.Vector3.FromArray(payload.collider.velocity), payload.maximumRetry, payload.excludedMeshUniqueId);\n            var replyPayload = {\n                collidedMeshUniqueId: collider.collidedMesh,\n                collisionId: payload.collisionId,\n                newPosition: finalPosition.asArray()\n            };\n            var reply = {\n                error: BABYLON.WorkerReplyType.SUCCESS,\n                taskType: BABYLON.WorkerTaskType.COLLIDE,\n                payload: replyPayload\n            };\n            postMessage(reply, undefined);\n        };\n        return CollisionDetectorTransferable;\n    })();\n    BABYLON.CollisionDetectorTransferable = CollisionDetectorTransferable;\n    \/\/check if we are in a web worker, as this code should NOT run on the main UI thread\n    if (self && !self.document) {\n        var collisionDetector = new CollisionDetectorTransferable();\n        console.log(\"worker started\");\n        var onNewMessage = function (event) {\n            var message = event.data;\n            switch (message.taskType) {\n                case BABYLON.WorkerTaskType.INIT:\n                    collisionDetector.onInit(message.payload);\n                    break;\n                case BABYLON.WorkerTaskType.COLLIDE:\n                    collisionDetector.onCollision(message.payload);\n                    break;\n                case BABYLON.WorkerTaskType.UPDATE:\n                    collisionDetector.onUpdate(message.payload);\n                    break;\n            }\n        };\n        self.onmessage = onNewMessage;\n    }\n})(BABYLON || (BABYLON = {}));\n\nvar BABYLON;\n(function (BABYLON) {\n    (function (WorkerTaskType) {\n        WorkerTaskType[WorkerTaskType[\"INIT\"] = 0] = \"INIT\";\n        WorkerTaskType[WorkerTaskType[\"UPDATE\"] = 1] = \"UPDATE\";\n        WorkerTaskType[WorkerTaskType[\"COLLIDE\"] = 2] = \"COLLIDE\";\n    })(BABYLON.WorkerTaskType || (BABYLON.WorkerTaskType = {}));\n    var WorkerTaskType = BABYLON.WorkerTaskType;\n    (function (WorkerReplyType) {\n        WorkerReplyType[WorkerReplyType[\"SUCCESS\"] = 0] = \"SUCCESS\";\n        WorkerReplyType[WorkerReplyType[\"UNKNOWN_ERROR\"] = 1] = \"UNKNOWN_ERROR\";\n    })(BABYLON.WorkerReplyType || (BABYLON.WorkerReplyType = {}));\n    var WorkerReplyType = BABYLON.WorkerReplyType;\n    var CollisionCoordinatorWorker = (function () {\n        function CollisionCoordinatorWorker() {\n            var _this = this;\n            this._scaledPosition = BABYLON.Vector3.Zero();\n            this._scaledVelocity = BABYLON.Vector3.Zero();\n            this.onMeshUpdated = function (mesh) {\n                _this._addUpdateMeshesList[mesh.uniqueId] = CollisionCoordinatorWorker.SerializeMesh(mesh);\n            };\n            this.onGeometryUpdated = function (geometry) {\n                _this._addUpdateGeometriesList[geometry.id] = CollisionCoordinatorWorker.SerializeGeometry(geometry);\n            };\n            this._afterRender = function () {\n                var payload = {\n                    updatedMeshes: _this._addUpdateMeshesList,\n                    updatedGeometries: _this._addUpdateGeometriesList,\n                    removedGeometries: _this._toRemoveGeometryArray,\n                    removedMeshes: _this._toRemoveMeshesArray\n                };\n                var message = {\n                    payload: payload,\n                    taskType: 1 \/* UPDATE *\/\n                };\n                var serializable = [];\n                for (var id in payload.updatedGeometries) {\n                    if (payload.updatedGeometries.hasOwnProperty(id)) {\n                        \/\/prepare transferables\n                        serializable.push(message.payload.updatedGeometries[id].indices.buffer);\n                        serializable.push(message.payload.updatedGeometries[id].normals.buffer);\n                        serializable.push(message.payload.updatedGeometries[id].positions.buffer);\n                    }\n                }\n                \/\/this variable is here only in case the update takes longer than a frame! \n                _this._runningUpdated++;\n                _this._worker.postMessage(message, serializable);\n                _this._addUpdateMeshesList = {};\n                _this._addUpdateGeometriesList = {};\n                _this._toRemoveGeometryArray = [];\n                _this._toRemoveMeshesArray = [];\n            };\n            this._onMessageFromWorker = function (e) {\n                var returnData = e.data;\n                if (returnData.error != 0 \/* SUCCESS *\/) {\n                    \/\/TODO what errors can be returned from the worker?\n                    BABYLON.Tools.Warn(\"error returned from worker!\");\n                    return;\n                }\n                switch (returnData.taskType) {\n                    case 0 \/* INIT *\/:\n                        \/\/TODO is init required after worker is done initializing?\n                        _this._init = true;\n                        break;\n                    case 1 \/* UPDATE *\/:\n                        _this._runningUpdated--;\n                        break;\n                    case 2 \/* COLLIDE *\/:\n                        _this._runningCollisionTask = false;\n                        var returnPayload = returnData.payload;\n                        if (!_this._collisionsCallbackArray[returnPayload.collisionId])\n                            return;\n                        _this._collisionsCallbackArray[returnPayload.collisionId](returnPayload.collisionId, BABYLON.Vector3.FromArray(returnPayload.newPosition), _this._scene.getMeshByUniqueID(returnPayload.collidedMeshUniqueId));\n                        \/\/cleanup\n                        _this._collisionsCallbackArray[returnPayload.collisionId] = undefined;\n                        break;\n                }\n            };\n            this._collisionsCallbackArray = [];\n            this._init = false;\n            this._runningUpdated = 0;\n            this._runningCollisionTask = false;\n            this._addUpdateMeshesList = {};\n            this._addUpdateGeometriesList = {};\n            this._toRemoveGeometryArray = [];\n            this._toRemoveMeshesArray = [];\n        }\n        CollisionCoordinatorWorker.prototype.getNewPosition = function (position, velocity, collider, maximumRetry, excludedMesh, onNewPosition, collisionIndex) {\n            if (this._collisionsCallbackArray[collisionIndex])\n                return;\n            position.divideToRef(collider.radius, this._scaledPosition);\n            velocity.divideToRef(collider.radius, this._scaledVelocity);\n            this._collisionsCallbackArray[collisionIndex] = onNewPosition;\n        };\n        CollisionCoordinatorWorker.prototype.init = function (scene) {\n            this._scene = scene;\n            this._scene.registerAfterRender(this._afterRender);\n            var blobURL = URL.createObjectURL(new Blob([\'(\', \"\".toString(), \')()\'], { type: \'application\/javascript\' }));\n            this._worker = new Worker(blobURL);\n            URL.revokeObjectURL(blobURL);\n        };\n        CollisionCoordinatorWorker.prototype.destroy = function () {\n            this._scene.unregisterAfterRender(this._afterRender);\n            this._worker.terminate();\n        };\n        CollisionCoordinatorWorker.prototype.onMeshAdded = function (mesh) {\n            mesh.registerAfterWorldMatrixUpdate(this.onMeshUpdated);\n            this.onMeshUpdated(mesh);\n        };\n        CollisionCoordinatorWorker.prototype.onMeshRemoved = function (mesh) {\n            this._toRemoveMeshesArray.push(mesh.uniqueId);\n        };\n        CollisionCoordinatorWorker.prototype.onGeometryAdded = function (geometry) {\n            \/\/TODO this will break if the user uses his own function. This should be an array of callbacks!\n            geometry.onGeometryUpdated = this.onGeometryUpdated;\n            this.onGeometryUpdated(geometry);\n        };\n        CollisionCoordinatorWorker.prototype.onGeometryDeleted = function (geometry) {\n            this._toRemoveGeometryArray.push(geometry.id);\n        };\n        CollisionCoordinatorWorker.SerializeMesh = function (mesh) {\n            var submeshes = [];\n            if (mesh.subMeshes) {\n                submeshes = mesh.subMeshes.map(function (sm, idx) {\n                    return {\n                        position: idx,\n                        verticesStart: sm.verticesStart,\n                        verticesCount: sm.verticesCount,\n                        indexStart: sm.indexStart,\n                        indexCount: sm.indexCount,\n                        hasMaterial: !!sm.getMaterial()\n                    };\n                });\n            }\n            var geometryId = mesh.geometry ? mesh.geometry.id : null;\n            return {\n                uniqueId: mesh.uniqueId,\n                id: mesh.id,\n                name: mesh.name,\n                geometryId: geometryId,\n                sphereCenter: mesh.getBoundingInfo().boundingSphere.centerWorld.asArray(),\n                sphereRadius: mesh.getBoundingInfo().boundingSphere.radiusWorld,\n                boxMinimum: mesh.getBoundingInfo().boundingBox.minimumWorld.asArray(),\n                boxMaximum: mesh.getBoundingInfo().boundingBox.maximumWorld.asArray(),\n                worldMatrixFromCache: mesh.worldMatrixFromCache.asArray(),\n                subMeshes: submeshes,\n                checkCollisions: mesh.checkCollisions\n            };\n        };\n        CollisionCoordinatorWorker.SerializeGeometry = function (geometry) {\n            return {\n                id: geometry.id,\n                positions: new Float32Array(geometry.getVerticesData(BABYLON.VertexBuffer.PositionKind) || []),\n                normals: new Float32Array(geometry.getVerticesData(BABYLON.VertexBuffer.NormalKind) || []),\n                indices: new Int32Array(geometry.getIndices() || []),\n            };\n        };\n        return CollisionCoordinatorWorker;\n    })();\n    BABYLON.CollisionCoordinatorWorker = CollisionCoordinatorWorker;\n    var CollisionCoordinatorLegacy = (function () {\n        function CollisionCoordinatorLegacy() {\n            this._scaledPosition = BABYLON.Vector3.Zero();\n            this._scaledVelocity = BABYLON.Vector3.Zero();\n            this._finalPosition = BABYLON.Vector3.Zero();\n        }\n        CollisionCoordinatorLegacy.prototype.getNewPosition = function (position, velocity, collider, maximumRetry, excludedMesh, onNewPosition, collisionIndex) {\n            position.divideToRef(collider.radius, this._scaledPosition);\n            velocity.divideToRef(collider.radius, this._scaledVelocity);\n            collider.retry = 0;\n            collider.initialVelocity = this._scaledVelocity;\n            collider.initialPosition = this._scaledPosition;\n            this._collideWithWorld(this._scaledPosition, this._scaledVelocity, collider, maximumRetry, this._finalPosition, excludedMesh);\n            this._finalPosition.multiplyInPlace(collider.radius);\n            \/\/run the callback\n            onNewPosition(collisionIndex, this._finalPosition, collider.collidedMesh);\n        };\n        CollisionCoordinatorLegacy.prototype.init = function (scene) {\n            this._scene = scene;\n        };\n        CollisionCoordinatorLegacy.prototype.destroy = function () {\n            \/\/Legacy need no destruction method.\n        };\n        \/\/No update in legacy mode\n        CollisionCoordinatorLegacy.prototype.onMeshAdded = function (mesh) {\n        };\n        CollisionCoordinatorLegacy.prototype.onMeshUpdated = function (mesh) {\n        };\n        CollisionCoordinatorLegacy.prototype.onMeshRemoved = function (mesh) {\n        };\n        CollisionCoordinatorLegacy.prototype.onGeometryAdded = function (geometry) {\n        };\n        CollisionCoordinatorLegacy.prototype.onGeometryUpdated = function (geometry) {\n        };\n        CollisionCoordinatorLegacy.prototype.onGeometryDeleted = function (geometry) {\n        };\n        CollisionCoordinatorLegacy.prototype._collideWithWorld = function (position, velocity, collider, maximumRetry, finalPosition, excludedMesh) {\n            if (excludedMesh === void 0) { excludedMesh = null; }\n            var closeDistance = BABYLON.Engine.CollisionsEpsilon * 10.0;\n            if (collider.retry >= maximumRetry) {\n                finalPosition.copyFrom(position);\n                return;\n            }\n            collider._initialize(position, velocity, closeDistance);\n            for (var index = 0; index < this._scene.meshes.length; index++) {\n                var mesh = this._scene.meshes[index];\n                if (mesh.isEnabled() && mesh.checkCollisions && mesh.subMeshes && mesh !== excludedMesh) {\n                    mesh._checkCollision(collider);\n                }\n            }\n            if (!collider.collisionFound) {\n                position.addToRef(velocity, finalPosition);\n                return;\n            }\n            if (velocity.x !== 0 || velocity.y !== 0 || velocity.z !== 0) {\n                collider._getResponse(position, velocity);\n            }\n            if (velocity.length() <= closeDistance) {\n                finalPosition.copyFrom(position);\n                return;\n            }\n            collider.retry++;\n            this._collideWithWorld(position, velocity, collider, maximumRetry, finalPosition, excludedMesh);\n        };\n        return CollisionCoordinatorLegacy;\n    })();\n    BABYLON.CollisionCoordinatorLegacy = CollisionCoordinatorLegacy;\n})(BABYLON || (BABYLON = {}));\n\nvar BABYLON;\n(function (BABYLON) {\n    var Color3 = (function () {\n        function Color3(r, g, b) {\n            if (r === void 0) { r = 0; }\n            if (g === void 0) { g = 0; }\n            if (b === void 0) { b = 0; }\n            this.r = r;\n            this.g = g;\n            this.b = b;\n        }\n        Color3.prototype.toString = function () {\n            return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \"}\";\n        };\n        \/\/ Operators\n        Color3.prototype.toArray = function (array, index) {\n            if (index === undefined) {\n                index = 0;\n            }\n            array[index] = this.r;\n            array[index + 1] = this.g;\n            array[index + 2] = this.b;\n            return this;\n        };\n        Color3.prototype.toColor4 = function (alpha) {\n            if (alpha === void 0) { alpha = 1; }\n            return new Color4(this.r, this.g, this.b, alpha);\n        };\n        Color3.prototype.asArray = function () {\n            var result = [];\n            this.toArray(result, 0);\n            return result;\n        };\n        Color3.prototype.toLuminance = function () {\n            return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;\n        };\n        Color3.prototype.multiply = function (otherColor) {\n            return new Color3(this.r * otherColor.r, this.g * otherColor.g, this.b * otherColor.b);\n        };\n        Color3.prototype.multiplyToRef = function (otherColor, result) {\n            result.r = this.r * otherColor.r;\n            result.g = this.g * otherColor.g;\n            result.b = this.b * otherColor.b;\n            return this;\n        };\n        Color3.prototype.equals = function (otherColor) {\n            return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b;\n        };\n        Color3.prototype.scale = function (scale) {\n            return new Color3(this.r * scale, this.g * scale, this.b * scale);\n        };\n        Color3.prototype.scaleToRef = function (scale, result) {\n            result.r = this.r * scale;\n            result.g = this.g * scale;\n            result.b = this.b * scale;\n            return this;\n        };\n        Color3.prototype.add = function (otherColor) {\n            return new Color3(this.r + otherColor.r, this.g + otherColor.g, this.b + otherColor.b);\n        };\n        Color3.prototype.addToRef = function (otherColor, result) {\n            result.r = this.r + otherColor.r;\n            result.g = this.g + otherColor.g;\n            result.b = this.b + otherColor.b;\n            return this;\n        };\n        Color3.prototype.subtract = function (otherColor) {\n            return new Color3(this.r - otherColor.r, this.g - otherColor.g, this.b - otherColor.b);\n        };\n        Color3.prototype.subtractToRef = function (otherColor, result) {\n            result.r = this.r - otherColor.r;\n            result.g = this.g - otherColor.g;\n            result.b = this.b - otherColor.b;\n            return this;\n        };\n        Color3.prototype.clone = function () {\n            return new Color3(this.r, this.g, this.b);\n        };\n        Color3.prototype.copyFrom = function (source) {\n            this.r = source.r;\n            this.g = source.g;\n            this.b = source.b;\n            return this;\n        };\n        Color3.prototype.copyFromFloats = function (r, g, b) {\n            this.r = r;\n            this.g = g;\n            this.b = b;\n            return this;\n        };\n        \/\/ Statics\n        Color3.FromArray = function (array, offset) {\n            if (offset === void 0) { offset = 0; }\n            return new Color3(array[offset], array[offset + 1], array[offset + 2]);\n        };\n        Color3.FromInts = function (r, g, b) {\n            return new Color3(r \/ 255.0, g \/ 255.0, b \/ 255.0);\n        };\n        Color3.Lerp = function (start, end, amount) {\n            var r = start.r + ((end.r - start.r) * amount);\n            var g = start.g + ((end.g - start.g) * amount);\n            var b = start.b + ((end.b - start.b) * amount);\n            return new Color3(r, g, b);\n        };\n        Color3.Red = function () {\n            return new Color3(1, 0, 0);\n        };\n        Color3.Green = function () {\n            return new Color3(0, 1, 0);\n        };\n        Color3.Blue = function () {\n            return new Color3(0, 0, 1);\n        };\n        Color3.Black = function () {\n            return new Color3(0, 0, 0);\n        };\n        Color3.White = function () {\n            return new Color3(1, 1, 1);\n        };\n        Color3.Purple = function () {\n            return new Color3(0.5, 0, 0.5);\n        };\n        Color3.Magenta = function () {\n            return new Color3(1, 0, 1);\n        };\n        Color3.Yellow = function () {\n            return new Color3(1, 1, 0);\n        };\n        Color3.Gray = function () {\n            return new Color3(0.5, 0.5, 0.5);\n        };\n        return Color3;\n    })();\n    BABYLON.Color3 = Color3;\n    var Color4 = (function () {\n        function Color4(r, g, b, a) {\n            this.r = r;\n            this.g = g;\n            this.b = b;\n            this.a = a;\n        }\n        \/\/ Operators\n        Color4.prototype.addInPlace = function (right) {\n            this.r += right.r;\n            this.g += right.g;\n            this.b += right.b;\n            this.a += right.a;\n            return this;\n        };\n        Color4.prototype.asArray = function () {\n            var result = [];\n            this.toArray(result, 0);\n            return result;\n        };\n        Color4.prototype.toArray = function (array, index) {\n            if (index === undefined) {\n                index = 0;\n            }\n            array[index] = this.r;\n            array[index + 1] = this.g;\n            array[index + 2] = this.b;\n            array[index + 3] = this.a;\n            return this;\n        };\n        Color4.prototype.add = function (right) {\n            return new Color4(this.r + right.r, this.g + right.g, this.b + right.b, this.a + right.a);\n        };\n        Color4.prototype.subtract = function (right) {\n            return new Color4(this.r - right.r, this.g - right.g, this.b - right.b, this.a - right.a);\n        };\n        Color4.prototype.subtractToRef = function (right, result) {\n            result.r = this.r - right.r;\n            result.g = this.g - right.g;\n            result.b = this.b - right.b;\n            result.a = this.a - right.a;\n            return this;\n        };\n        Color4.prototype.scale = function (scale) {\n            return new Color4(this.r * scale, this.g * scale, this.b * scale, this.a * scale);\n        };\n        Color4.prototype.scaleToRef = function (scale, result) {\n            result.r = this.r * scale;\n            result.g = this.g * scale;\n            result.b = this.b * scale;\n            result.a = this.a * scale;\n            return this;\n        };\n        Color4.prototype.toString = function () {\n            return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \" A:\" + this.a + \"}\";\n        };\n        Color4.prototype.clone = function () {\n            return new Color4(this.r, this.g, this.b, this.a);\n        };\n        Color4.prototype.copyFrom = function (source) {\n            this.r = source.r;\n            this.g = source.g;\n            this.b = source.b;\n            this.a = source.a;\n            return this;\n        };\n        \/\/ Statics\n        Color4.Lerp = function (left, right, amount) {\n            var result = new Color4(0, 0, 0, 0);\n            Color4.LerpToRef(left, right, amount, result);\n            return result;\n        };\n        Color4.LerpToRef = function (left, right, amount, result) {\n            result.r = left.r + (right.r - left.r) * amount;\n            result.g = left.g + (right.g - left.g) * amount;\n            result.b = left.b + (right.b - left.b) * amount;\n            result.a = left.a + (right.a - left.a) * amount;\n        };\n        Color4.FromArray = function (array, offset) {\n            if (offset === void 0) { offset = 0; }\n            return new Color4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n        };\n        Color4.FromInts = function (r, g, b, a) {\n            return new Color4(r \/ 255.0, g \/ 255.0, b \/ 255.0, a \/ 255.0);\n        };\n        return Color4;\n    })();\n    BABYLON.Color4 = Color4;\n    var Vector2 = (function () {\n        function Vector2(x, y) {\n            this.x = x;\n            this.y = y;\n        }\n        Vector2.prototype.toString = function () {\n            return \"{X: \" + this.x + \" Y:\" + this.y + \"}\";\n        };\n        \/\/ Operators\n        Vector2.prototype.toArray = function (array, index) {\n            if (index === void 0) { index = 0; }\n            array[index] = this.x;\n            array[index + 1] = this.y;\n            return this;\n        };\n        Vector2.prototype.asArray = function () {\n            var result = [];\n            this.toArray(result, 0);\n            return result;\n        };\n        Vector2.prototype.copyFrom = function (source) {\n            this.x = source.x;\n            this.y = source.y;\n            return this;\n        };\n        Vector2.prototype.copyFromFloats = function (x, y) {\n            this.x = x;\n            this.y = y;\n            return this;\n        };\n        Vector2.prototype.add = function (otherVector) {\n            return new Vector2(this.x + otherVector.x, this.y + otherVector.y);\n        };\n        Vector2.prototype.addVector3 = function (otherVector) {\n            return new Vector2(this.x + otherVector.x, this.y + otherVector.y);\n        };\n        Vector2.prototype.subtract = function (otherVector) {\n            return new Vector2(this.x - otherVector.x, this.y - otherVector.y);\n        };\n        Vector2.prototype.subtractInPlace = function (otherVector) {\n            this.x -= otherVector.x;\n            this.y -= otherVector.y;\n            return this;\n        };\n        Vector2.prototype.multiplyInPlace = function (otherVector) {\n            this.x *= otherVector.x;\n            this.y *= otherVector.y;\n            return this;\n        };\n        Vector2.prototype.multiply = function (otherVector) {\n            return new Vector2(this.x * otherVector.x, this.y * otherVector.y);\n        };\n        Vector2.prototype.multiplyToRef = function (otherVector, result) {\n            result.x = this.x * otherVector.x;\n            result.y = this.y * otherVector.y;\n            return this;\n        };\n        Vector2.prototype.multiplyByFloats = function (x, y) {\n            return new Vector2(this.x * x, this.y * y);\n        };\n        Vector2.prototype.divide = function (otherVector) {\n            return new Vector2(this.x \/ otherVector.x, this.y \/ otherVector.y);\n        };\n        Vector2.prototype.divideToRef = function (otherVector, result) {\n            result.x = this.x \/ otherVector.x;\n            result.y = this.y \/ otherVector.y;\n            return this;\n        };\n        Vector2.prototype.negate = function () {\n            return new Vector2(-this.x, -this.y);\n        };\n        Vector2.prototype.scaleInPlace = function (scale) {\n            this.x *= scale;\n            this.y *= scale;\n            return this;\n        };\n        Vector2.prototype.scale = function (scale) {\n            return new Vector2(this.x * scale, this.y * scale);\n        };\n        Vector2.prototype.equals = function (otherVector) {\n            return otherVector && this.x === otherVector.x && this.y === otherVector.y;\n        };\n        \/\/ Properties\n        Vector2.prototype.length = function () {\n            return Math.sqrt(this.x * this.x + this.y * this.y);\n        };\n        Vector2.prototype.lengthSquared = function () {\n            return (this.x * this.x + this.y * this.y);\n        };\n        \/\/ Methods\n        Vector2.prototype.normalize = function () {\n            var len = this.length();\n            if (len === 0)\n                return this;\n            var num = 1.0 \/ len;\n            this.x *= num;\n            this.y *= num;\n            return this;\n        };\n        Vector2.prototype.clone = function () {\n            return new Vector2(this.x, this.y);\n        };\n        \/\/ Statics\n        Vector2.Zero = function () {\n            return new Vector2(0, 0);\n        };\n        Vector2.FromArray = function (array, offset) {\n            if (offset === void 0) { offset = 0; }\n            return new Vector2(array[offset], array[offset + 1]);\n        };\n        Vector2.FromArrayToRef = function (array, offset, result) {\n            result.x = array[offset];\n            result.y = array[offset + 1];\n        };\n        Vector2.CatmullRom = function (value1, value2, value3, value4, amount) {\n            var squared = amount * amount;\n            var cubed = amount * squared;\n            var x = 0.5 * ((((2.0 * value2.x) + ((-value1.x + value3.x) * amount)) + (((((2.0 * value1.x) - (5.0 * value2.x)) + (4.0 * value3.x)) - value4.x) * squared)) + ((((-value1.x + (3.0 * value2.x)) - (3.0 * value3.x)) + value4.x) * cubed));\n            var y = 0.5 * ((((2.0 * value2.y) + ((-value1.y + value3.y) * amount)) + (((((2.0 * value1.y) - (5.0 * value2.y)) + (4.0 * value3.y)) - value4.y) * squared)) + ((((-value1.y + (3.0 * value2.y)) - (3.0 * value3.y)) + value4.y) * cubed));\n            return new Vector2(x, y);\n        };\n        Vector2.Clamp = function (value, min, max) {\n            var x = value.x;\n            x = (x > max.x) ? max.x : x;\n            x = (x < min.x) ? min.x : x;\n            var y = value.y;\n            y = (y > max.y) ? max.y : y;\n            y = (y < min.y) ? min.y : y;\n            return new Vector2(x, y);\n        };\n        Vector2.Hermite = function (value1, tangent1, value2, tangent2, amount) {\n            var squared = amount * amount;\n            var cubed = amount * squared;\n            var part1 = ((2.0 * cubed) - (3.0 * squared)) + 1.0;\n            var part2 = (-2.0 * cubed) + (3.0 * squared);\n            var part3 = (cubed - (2.0 * squared)) + amount;\n            var part4 = cubed - squared;\n            var x = (((value1.x * part1) + (value2.x * part2)) + (tangent1.x * part3)) + (tangent2.x * part4);\n            var y = (((value1.y * part1) + (value2.y * part2)) + (tangent1.y * part3)) + (tangent2.y * part4);\n            return new Vector2(x, y);\n        };\n        Vector2.Lerp = function (start, end, amount) {\n            var x = start.x + ((end.x - start.x) * amount);\n            var y = start.y + ((end.y - start.y) * amount);\n            return new Vector2(x, y);\n        };\n        Vector2.Dot = function (left, right) {\n            return left.x * right.x + left.y * right.y;\n        };\n        Vector2.Normalize = function (vector) {\n            var newVector = vector.clone();\n            newVector.normalize();\n            return newVector;\n        };\n        Vector2.Minimize = function (left, right) {\n            var x = (left.x < right.x) ? left.x : right.x;\n            var y = (left.y < right.y) ? left.y : right.y;\n            return new Vector2(x, y);\n        };\n        Vector2.Maximize = function (left, right) {\n            var x = (left.x > right.x) ? left.x : right.x;\n            var y = (left.y > right.y) ? left.y : right.y;\n            return new Vector2(x, y);\n        };\n        Vector2.Transform = function (vector, transformation) {\n            var x = (vector.x * transformation.m[0]) + (vector.y * transformation.m[4]);\n            var y = (vector.x * transformation.m[1]) + (vector.y * transformation.m[5]);\n            return new Vector2(x, y);\n        };\n        Vector2.Distance = function (value1, value2) {\n            return Math.sqrt(Vector2.DistanceSquared(value1, value2));\n        };\n        Vector2.DistanceSquared = function (value1, value2) {\n            var x = value1.x - value2.x;\n            var y = value1.y - value2.y;\n            return (x * x) + (y * y);\n        };\n        return Vector2;\n    })();\n    BABYLON.Vector2 = Vector2;\n    var Vector3 = (function () {\n        function Vector3(x, y, z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n        Vector3.prototype.toString = function () {\n            return \"{X: \" + this.x + \" Y:\" + this.y + \" Z:\" + this.z + \"}\";\n        };\n        \/\/ Operators\n        Vector3.prototype.asArray = function () {\n            var result = [];\n            this.toArray(result, 0);\n            return result;\n        };\n        Vector3.prototype.toArray = function (array, index) {\n            if (index === void 0) { index = 0; }\n            array[index] = this.x;\n            array[index + 1] = this.y;\n            array[index + 2] = this.z;\n            return this;\n        };\n        Vector3.prototype.toQuaternion = function () {\n            var result = new Quaternion(0, 0, 0, 1);\n            var cosxPlusz = Math.cos((this.x + this.z) * 0.5);\n            var sinxPlusz = Math.sin((this.x + this.z) * 0.5);\n            var coszMinusx = Math.cos((this.z - this.x) * 0.5);\n            var sinzMinusx = Math.sin((this.z - this.x) * 0.5);\n            var cosy = Math.cos(this.y * 0.5);\n            var siny = Math.sin(this.y * 0.5);\n            result.x = coszMinusx * siny;\n            result.y = -sinzMinusx * siny;\n            result.z = sinxPlusz * cosy;\n            result.w = cosxPlusz * cosy;\n            return result;\n        };\n        Vector3.prototype.addInPlace = function (otherVector) {\n            this.x += otherVector.x;\n            this.y += otherVector.y;\n            this.z += otherVector.z;\n            return this;\n        };\n        Vector3.prototype.add = function (otherVector) {\n            return new Vector3(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z);\n        };\n        Vector3.prototype.addToRef = function (otherVector, result) {\n            result.x = this.x + otherVector.x;\n            result.y = this.y + otherVector.y;\n            result.z = this.z + otherVector.z;\n            return this;\n        };\n        Vector3.prototype.subtractInPlace = function (otherVector) {\n            this.x -= otherVector.x;\n            this.y -= otherVector.y;\n            this.z -= otherVector.z;\n            return this;\n        };\n        Vector3.prototype.subtract = function (otherVector) {\n            return new Vector3(this.x - otherVector.x, this.y - otherVector.y, this.z - otherVector.z);\n        };\n        Vector3.prototype.subtractToRef = function (otherVector, result) {\n            result.x = this.x - otherVector.x;\n            result.y = this.y - otherVector.y;\n            result.z = this.z - otherVector.z;\n            return this;\n        };\n        Vector3.prototype.subtractFromFloats = function (x, y, z) {\n            return new Vector3(this.x - x, this.y - y, this.z - z);\n        };\n        Vector3.prototype.subtractFromFloatsToRef = function (x, y, z, result) {\n            result.x = this.x - x;\n            result.y = this.y - y;\n            result.z = this.z - z;\n            return this;\n        };\n        Vector3.prototype.negate = function () {\n            return new Vector3(-this.x, -this.y, -this.z);\n        };\n        Vector3.prototype.scaleInPlace = function (scale) {\n            this.x *= scale;\n            this.y *= scale;\n            this.z *= scale;\n            return this;\n        };\n        Vector3.prototype.scale = function (scale) {\n            return new Vector3(this.x * scale, this.y * scale, this.z * scale);\n        };\n        Vector3.prototype.scaleToRef = function (scale, result) {\n            result.x = this.x * scale;\n            result.y = this.y * scale;\n            result.z = this.z * scale;\n        };\n        Vector3.prototype.equals = function (otherVector) {\n            return otherVector && this.x === otherVector.x && this.y === otherVector.y && this.z === otherVector.z;\n        };\n        Vector3.prototype.equalsWithEpsilon = function (otherVector) {\n            return Math.abs(this.x - otherVector.x) < BABYLON.Engine.Epsilon && Math.abs(this.y - otherVector.y) < BABYLON.Engine.Epsilon && Math.abs(this.z - otherVector.z) < BABYLON.Engine.Epsilon;\n        };\n        Vector3.prototype.equalsToFloats = function (x, y, z) {\n            return this.x === x && this.y === y && this.z === z;\n        };\n        Vector3.prototype.multiplyInPlace = function (otherVector) {\n            this.x *= otherVector.x;\n            this.y *= otherVector.y;\n            this.z *= otherVector.z;\n            return this;\n        };\n        Vector3.prototype.multiply = function (otherVector) {\n            return new Vector3(this.x * otherVector.x, this.y * otherVector.y, this.z * otherVector.z);\n        };\n        Vector3.prototype.multiplyToRef = function (otherVector, result) {\n            result.x = this.x * otherVector.x;\n            result.y = this.y * otherVector.y;\n            result.z = this.z * otherVector.z;\n            return this;\n        };\n        Vector3.prototype.multiplyByFloats = function (x, y, z) {\n            return new Vector3(this.x * x, this.y * y, this.z * z);\n        };\n        Vector3.prototype.divide = function (otherVector) {\n            return new Vector3(this.x \/ otherVector.x, this.y \/ otherVector.y, this.z \/ otherVector.z);\n        };\n        Vector3.prototype.divideToRef = function (otherVector, result) {\n            result.x = this.x \/ otherVector.x;\n            result.y = this.y \/ otherVector.y;\n            result.z = this.z \/ otherVector.z;\n            return this;\n        };\n        Vector3.prototype.MinimizeInPlace = function (other) {\n            if (other.x < this.x)\n                this.x = other.x;\n            if (other.y < this.y)\n                this.y = other.y;\n            if (other.z < this.z)\n                this.z = other.z;\n            return this;\n        };\n        Vector3.prototype.MaximizeInPlace = function (other) {\n            if (other.x > this.x)\n                this.x = other.x;\n            if (other.y > this.y)\n                this.y = other.y;\n            if (other.z > this.z)\n                this.z = other.z;\n            return this;\n        };\n        \/\/ Properties\n        Vector3.prototype.length = function () {\n            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n        };\n        Vector3.prototype.lengthSquared = function () {\n            return (this.x * this.x + this.y * this.y + this.z * this.z);\n        };\n        \/\/ Methods\n        Vector3.prototype.normalize = function () {\n            var len = this.length();\n            if (len === 0)\n                return this;\n            var num = 1.0 \/ len;\n            this.x *= num;\n            this.y *= num;\n            this.z *= num;\n            return this;\n        };\n        Vector3.prototype.clone = function () {\n            return new Vector3(this.x, this.y, this.z);\n        };\n        Vector3.prototype.copyFrom = function (source) {\n            this.x = source.x;\n            this.y = source.y;\n            this.z = source.z;\n            return this;\n        };\n        Vector3.prototype.copyFromFloats = function (x, y, z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            return this;\n        };\n        \/\/ Statics\n        Vector3.GetClipFactor = function (vector0, vector1, axis, size) {\n            var d0 = Vector3.Dot(vector0, axis) - size;\n            var d1 = Vector3.Dot(vector1, axis) - size;\n            var s = d0 \/ (d0 - d1);\n            return s;\n        };\n        Vector3.FromArray = function (array, offset) {\n            if (!offset) {\n                offset = 0;\n            }\n            return new Vector3(array[offset], array[offset + 1], array[offset + 2]);\n        };\n        Vector3.FromArrayToRef = function (array, offset, result) {\n            result.x = array[offset];\n            result.y = array[offset + 1];\n            result.z = array[offset + 2];\n        };\n        Vector3.FromFloatArrayToRef = function (array, offset, result) {\n            result.x = array[offset];\n            result.y = array[offset + 1];\n            result.z = array[offset + 2];\n        };\n        Vector3.FromFloatsToRef = function (x, y, z, result) {\n            result.x = x;\n            result.y = y;\n            result.z = z;\n        };\n        Vector3.Zero = function () {\n            return new Vector3(0, 0, 0);\n        };\n        Vector3.Up = function () {\n            return new Vector3(0, 1.0, 0);\n        };\n        Vector3.TransformCoordinates = function (vector, transformation) {\n            var result = Vector3.Zero();\n            Vector3.TransformCoordinatesToRef(vector, transformation, result);\n            return result;\n        };\n        Vector3.TransformCoordinatesToRef = function (vector, transformation, result) {\n            var x = (vector.x * transformation.m[0]) + (vector.y * transformation.m[4]) + (vector.z * transformation.m[8]) + transformation.m[12];\n            var y = (vector.x * transformation.m[1]) + (vector.y * transformation.m[5]) + (vector.z * transformation.m[9]) + transformation.m[13];\n            var z = (vector.x * transformation.m[2]) + (vector.y * transformation.m[6]) + (vector.z * transformation.m[10]) + transformation.m[14];\n            var w = (vector.x * transformation.m[3]) + (vector.y * transformation.m[7]) + (vector.z * transformation.m[11]) + transformation.m[15];\n            result.x = x \/ w;\n            result.y = y \/ w;\n            result.z = z \/ w;\n        };\n        Vector3.TransformCoordinatesFromFloatsToRef = function (x, y, z, transformation, result) {\n            var rx = (x * transformation.m[0]) + (y * transformation.m[4]) + (z * transformation.m[8]) + transformation.m[12];\n            var ry = (x * transformation.m[1]) + (y * transformation.m[5]) + (z * transformation.m[9]) + transformation.m[13];\n            var rz = (x * transformation.m[2]) + (y * transformation.m[6]) + (z * transformation.m[10]) + transformation.m[14];\n            var rw = (x * transformation.m[3]) + (y * transformation.m[7]) + (z * transformation.m[11]) + transformation.m[15];\n            result.x = rx \/ rw;\n            result.y = ry \/ rw;\n            result.z = rz \/ rw;\n        };\n        Vector3.TransformCoordinatesToRefSIMD = function (vector, transformation, result) {\n            var v = SIMD.float32x4.loadXYZ(vector._data, 0);\n            var m0 = SIMD.float32x4.load(transformation.m, 0);\n            var m1 = SIMD.float32x4.load(transformation.m, 4);\n            var m2 = SIMD.float32x4.load(transformation.m, 8);\n            var m3 = SIMD.float32x4.load(transformation.m, 12);\n            var r = SIMD.float32x4.add(SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(v, 0, 0, 0, 0), m0), SIMD.float32x4.mul(SIMD.float32x4.swizzle(v, 1, 1, 1, 1), m1)), SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(v, 2, 2, 2, 2), m2), m3));\n            r = SIMD.float32x4.div(r, SIMD.float32x4.swizzle(r, 3, 3, 3, 3));\n            SIMD.float32x4.storeXYZ(result._data, 0, r);\n        };\n        Vector3.TransformCoordinatesFromFloatsToRefSIMD = function (x, y, z, transformation, result) {\n            var v0 = SIMD.float32x4.splat(x);\n            var v1 = SIMD.float32x4.splat(y);\n            var v2 = SIMD.float32x4.splat(z);\n            var m0 = SIMD.float32x4.load(transformation.m, 0);\n            var m1 = SIMD.float32x4.load(transformation.m, 4);\n            var m2 = SIMD.float32x4.load(transformation.m, 8);\n            var m3 = SIMD.float32x4.load(transformation.m, 12);\n            var r = SIMD.float32x4.add(SIMD.float32x4.add(SIMD.float32x4.mul(v0, m0), SIMD.float32x4.mul(v1, m1)), SIMD.float32x4.add(SIMD.float32x4.mul(v2, m2), m3));\n            r = SIMD.float32x4.div(r, SIMD.float32x4.swizzle(r, 3, 3, 3, 3));\n            SIMD.float32x4.storeXYZ(result._data, 0, r);\n        };\n        Vector3.TransformNormal = function (vector, transformation) {\n            var result = Vector3.Zero();\n            Vector3.TransformNormalToRef(vector, transformation, result);\n            return result;\n        };\n        Vector3.TransformNormalToRef = function (vector, transformation, result) {\n            result.x = (vector.x * transformation.m[0]) + (vector.y * transformation.m[4]) + (vector.z * transformation.m[8]);\n            result.y = (vector.x * transformation.m[1]) + (vector.y * transformation.m[5]) + (vector.z * transformation.m[9]);\n            result.z = (vector.x * transformation.m[2]) + (vector.y * transformation.m[6]) + (vector.z * transformation.m[10]);\n        };\n        Vector3.TransformNormalFromFloatsToRef = function (x, y, z, transformation, result) {\n            result.x = (x * transformation.m[0]) + (y * transformation.m[4]) + (z * transformation.m[8]);\n            result.y = (x * transformation.m[1]) + (y * transformation.m[5]) + (z * transformation.m[9]);\n            result.z = (x * transformation.m[2]) + (y * transformation.m[6]) + (z * transformation.m[10]);\n        };\n        Vector3.CatmullRom = function (value1, value2, value3, value4, amount) {\n            var squared = amount * amount;\n            var cubed = amount * squared;\n            var x = 0.5 * ((((2.0 * value2.x) + ((-value1.x + value3.x) * amount)) + (((((2.0 * value1.x) - (5.0 * value2.x)) + (4.0 * value3.x)) - value4.x) * squared)) + ((((-value1.x + (3.0 * value2.x)) - (3.0 * value3.x)) + value4.x) * cubed));\n            var y = 0.5 * ((((2.0 * value2.y) + ((-value1.y + value3.y) * amount)) + (((((2.0 * value1.y) - (5.0 * value2.y)) + (4.0 * value3.y)) - value4.y) * squared)) + ((((-value1.y + (3.0 * value2.y)) - (3.0 * value3.y)) + value4.y) * cubed));\n            var z = 0.5 * ((((2.0 * value2.z) + ((-value1.z + value3.z) * amount)) + (((((2.0 * value1.z) - (5.0 * value2.z)) + (4.0 * value3.z)) - value4.z) * squared)) + ((((-value1.z + (3.0 * value2.z)) - (3.0 * value3.z)) + value4.z) * cubed));\n            return new Vector3(x, y, z);\n        };\n        Vector3.Clamp = function (value, min, max) {\n            var x = value.x;\n            x = (x > max.x) ? max.x : x;\n            x = (x < min.x) ? min.x : x;\n            var y = value.y;\n            y = (y > max.y) ? max.y : y;\n            y = (y < min.y) ? min.y : y;\n            var z = value.z;\n            z = (z > max.z) ? max.z : z;\n            z = (z < min.z) ? min.z : z;\n            return new Vector3(x, y, z);\n        };\n        Vector3.Hermite = function (value1, tangent1, value2, tangent2, amount) {\n            var squared = amount * amount;\n            var cubed = amount * squared;\n            var part1 = ((2.0 * cubed) - (3.0 * squared)) + 1.0;\n            var part2 = (-2.0 * cubed) + (3.0 * squared);\n            var part3 = (cubed - (2.0 * squared)) + amount;\n            var part4 = cubed - squared;\n            var x = (((value1.x * part1) + (value2.x * part2)) + (tangent1.x * part3)) + (tangent2.x * part4);\n            var y = (((value1.y * part1) + (value2.y * part2)) + (tangent1.y * part3)) + (tangent2.y * part4);\n            var z = (((value1.z * part1) + (value2.z * part2)) + (tangent1.z * part3)) + (tangent2.z * part4);\n            return new Vector3(x, y, z);\n        };\n        Vector3.Lerp = function (start, end, amount) {\n            var x = start.x + ((end.x - start.x) * amount);\n            var y = start.y + ((end.y - start.y) * amount);\n            var z = start.z + ((end.z - start.z) * amount);\n            return new Vector3(x, y, z);\n        };\n        Vector3.Dot = function (left, right) {\n            return (left.x * right.x + left.y * right.y + left.z * right.z);\n        };\n        Vector3.Cross = function (left, right) {\n            var result = Vector3.Zero();\n            Vector3.CrossToRef(left, right, result);\n            return result;\n        };\n        Vector3.CrossToRef = function (left, right, result) {\n            result.x = left.y * right.z - left.z * right.y;\n            result.y = left.z * right.x - left.x * right.z;\n            result.z = left.x * right.y - left.y * right.x;\n        };\n        Vector3.Normalize = function (vector) {\n            var result = Vector3.Zero();\n            Vector3.NormalizeToRef(vector, result);\n            return result;\n        };\n        Vector3.NormalizeToRef = function (vector, result) {\n            result.copyFrom(vector);\n            result.normalize();\n        };\n        Vector3.Project = function (vector, world, transform, viewport) {\n            var cw = viewport.width;\n            var ch = viewport.height;\n            var cx = viewport.x;\n            var cy = viewport.y;\n            var viewportMatrix = Matrix.FromValues(cw \/ 2.0, 0, 0, 0, 0, -ch \/ 2.0, 0, 0, 0, 0, 1, 0, cx + cw \/ 2.0, ch \/ 2.0 + cy, 0, 1);\n            var finalMatrix = world.multiply(transform).multiply(viewportMatrix);\n            return Vector3.TransformCoordinates(vector, finalMatrix);\n        };\n        Vector3.UnprojectFromTransform = function (source, viewportWidth, viewportHeight, world, transform) {\n            var matrix = world.multiply(transform);\n            matrix.invert();\n            source.x = source.x \/ viewportWidth * 2 - 1;\n            source.y = -(source.y \/ viewportHeight * 2 - 1);\n            var vector = Vector3.TransformCoordinates(source, matrix);\n            var num = source.x * matrix.m[3] + source.y * matrix.m[7] + source.z * matrix.m[11] + matrix.m[15];\n            if (BABYLON.Tools.WithinEpsilon(num, 1.0)) {\n                vector = vector.scale(1.0 \/ num);\n            }\n            return vector;\n        };\n        Vector3.Unproject = function (source, viewportWidth, viewportHeight, world, view, projection) {\n            var matrix = world.multiply(view).multiply(projection);\n            matrix.invert();\n            source.x = source.x \/ viewportWidth * 2 - 1;\n            source.y = -(source.y \/ viewportHeight * 2 - 1);\n            var vector = Vector3.TransformCoordinates(source, matrix);\n            var num = source.x * matrix.m[3] + source.y * matrix.m[7] + source.z * matrix.m[11] + matrix.m[15];\n            if (BABYLON.Tools.WithinEpsilon(num, 1.0)) {\n                vector = vector.scale(1.0 \/ num);\n            }\n            return vector;\n        };\n        Vector3.Minimize = function (left, right) {\n            var min = left.clone();\n            min.MinimizeInPlace(right);\n            return min;\n        };\n        Vector3.Maximize = function (left, right) {\n            var max = left.clone();\n            max.MaximizeInPlace(right);\n            return max;\n        };\n        Vector3.Distance = function (value1, value2) {\n            return Math.sqrt(Vector3.DistanceSquared(value1, value2));\n        };\n        Vector3.DistanceSquared = function (value1, value2) {\n            var x = value1.x - value2.x;\n            var y = value1.y - value2.y;\n            var z = value1.z - value2.z;\n            return (x * x) + (y * y) + (z * z);\n        };\n        Vector3.Center = function (value1, value2) {\n            var center = value1.add(value2);\n            center.scaleInPlace(0.5);\n            return center;\n        };\n        return Vector3;\n    })();\n    BABYLON.Vector3 = Vector3;\n    \/\/Vector4 class created for EulerAngle class conversion to Quaternion\n    var Vector4 = (function () {\n        function Vector4(x, y, z, w) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            this.w = w;\n        }\n        Vector4.prototype.toString = function () {\n            return \"{X: \" + this.x + \" Y:\" + this.y + \" Z:\" + this.z + \"W:\" + this.w + \"}\";\n        };\n        \/\/ Operators\n        Vector4.prototype.asArray = function () {\n            var result = [];\n            this.toArray(result, 0);\n            return result;\n        };\n        Vector4.prototype.toArray = function (array, index) {\n            if (index === undefined) {\n                index = 0;\n            }\n            array[index] = this.x;\n            array[index + 1] = this.y;\n            array[index + 2] = this.z;\n            array[index + 3] = this.w;\n            return this;\n        };\n        Vector4.prototype.addInPlace = function (otherVector) {\n            this.x += otherVector.x;\n            this.y += otherVector.y;\n            this.z += otherVector.z;\n            this.w += otherVector.w;\n            return this;\n        };\n        Vector4.prototype.add = function (otherVector) {\n            return new Vector4(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z, this.w + otherVector.w);\n        };\n        Vector4.prototype.addToRef = function (otherVector, result) {\n            result.x = this.x + otherVector.x;\n            result.y = this.y + otherVector.y;\n            result.z = this.z + otherVector.z;\n            result.w = this.w + otherVector.w;\n            return this;\n        };\n        Vector4.prototype.subtractInPlace = function (otherVector) {\n            this.x -= otherVector.x;\n            this.y -= otherVector.y;\n            this.z -= otherVector.z;\n            this.w -= otherVector.w;\n            return this;\n        };\n        Vector4.prototype.subtract = function (otherVector) {\n            return new Vector4(this.x - otherVector.x, this.y - otherVector.y, this.z - otherVector.z, this.w - otherVector.w);\n        };\n        Vector4.prototype.subtractToRef = function (otherVector, result) {\n            result.x = this.x - otherVector.x;\n            result.y = this.y - otherVector.y;\n            result.z = this.z - otherVector.z;\n            result.w = this.w - otherVector.w;\n            return this;\n        };\n        Vector4.prototype.subtractFromFloats = function (x, y, z, w) {\n            return new Vector4(this.x - x, this.y - y, this.z - z, this.w - w);\n        };\n        Vector4.prototype.subtractFromFloatsToRef = function (x, y, z, w, result) {\n            result.x = this.x - x;\n            result.y = this.y - y;\n            result.z = this.z - z;\n            result.w = this.w - w;\n            return this;\n        };\n        Vector4.prototype.negate = function () {\n            return new Vector4(-this.x, -this.y, -this.z, -this.w);\n        };\n        Vector4.prototype.scaleInPlace = function (scale) {\n            this.x *= scale;\n            this.y *= scale;\n            this.z *= scale;\n            this.w *= scale;\n            return this;\n        };\n        Vector4.prototype.scale = function (scale) {\n            return new Vector4(this.x * scale, this.y * scale, this.z * scale, this.w * scale);\n        };\n        Vector4.prototype.scaleToRef = function (scale, result) {\n            result.x = this.x * scale;\n            result.y = this.y * scale;\n            result.z = this.z * scale;\n            result.w = this.w * scale;\n        };\n        Vector4.prototype.equals = function (otherVector) {\n            return otherVector && this.x === otherVector.x && this.y === otherVector.y && this.z === otherVector.z && this.w === otherVector.w;\n        };\n        Vector4.prototype.equalsWithEpsilon = function (otherVector) {\n            return Math.abs(this.x - otherVector.x) < BABYLON.Engine.Epsilon && Math.abs(this.y - otherVector.y) < BABYLON.Engine.Epsilon && Math.abs(this.z - otherVector.z) < BABYLON.Engine.Epsilon && Math.abs(this.w - otherVector.w) < BABYLON.Engine.Epsilon;\n        };\n        Vector4.prototype.equalsToFloats = function (x, y, z, w) {\n            return this.x === x && this.y === y && this.z === z && this.w === w;\n        };\n        Vector4.prototype.multiplyInPlace = function (otherVector) {\n            this.x *= otherVector.x;\n            this.y *= otherVector.y;\n            this.z *= otherVector.z;\n            this.w *= otherVector.w;\n            return this;\n        };\n        Vector4.prototype.multiply = function (otherVector) {\n            return new Vector4(this.x * otherVector.x, this.y * otherVector.y, this.z * otherVector.z, this.w * otherVector.w);\n        };\n        Vector4.prototype.multiplyToRef = function (otherVector, result) {\n            result.x = this.x * otherVector.x;\n            result.y = this.y * otherVector.y;\n            result.z = this.z * otherVector.z;\n            result.w = this.w * otherVector.w;\n            return this;\n        };\n        Vector4.prototype.multiplyByFloats = function (x, y, z, w) {\n            return new Vector4(this.x * x, this.y * y, this.z * z, this.w * w);\n        };\n        Vector4.prototype.divide = function (otherVector) {\n            return new Vector4(this.x \/ otherVector.x, this.y \/ otherVector.y, this.z \/ otherVector.z, this.w \/ otherVector.w);\n        };\n        Vector4.prototype.divideToRef = function (otherVector, result) {\n            result.x = this.x \/ otherVector.x;\n            result.y = this.y \/ otherVector.y;\n            result.z = this.z \/ otherVector.z;\n            result.w = this.w \/ otherVector.w;\n            return this;\n        };\n        Vector4.prototype.MinimizeInPlace = function (other) {\n            if (other.x < this.x)\n                this.x = other.x;\n            if (other.y < this.y)\n                this.y = other.y;\n            if (other.z < this.z)\n                this.z = other.z;\n            if (other.w < this.w)\n                this.w = other.w;\n            return this;\n        };\n        Vector4.prototype.MaximizeInPlace = function (other) {\n            if (other.x > this.x)\n                this.x = other.x;\n            if (other.y > this.y)\n                this.y = other.y;\n            if (other.z > this.z)\n                this.z = other.z;\n            if (other.w > this.w)\n                this.w = other.w;\n            return this;\n        };\n        \/\/ Properties\n        Vector4.prototype.length = function () {\n            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n        };\n        Vector4.prototype.lengthSquared = function () {\n            return (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n        };\n        \/\/ Methods\n        Vector4.prototype.normalize = function () {\n            var len = this.length();\n            if (len === 0)\n                return this;\n            var num = 1.0 \/ len;\n            this.x *= num;\n            this.y *= num;\n            this.z *= num;\n            this.w *= num;\n            return this;\n        };\n        Vector4.prototype.clone = function () {\n            return new Vector4(this.x, this.y, this.z, this.w);\n        };\n        Vector4.prototype.copyFrom = function (source) {\n            this.x = source.x;\n            this.y = source.y;\n            this.z = source.z;\n            this.w = source.w;\n            return this;\n        };\n        Vector4.prototype.copyFromFloats = function (x, y, z, w) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            this.w = w;\n            return this;\n        };\n        \/\/ Statics\n        Vector4.FromArray = function (array, offset) {\n            if (!offset) {\n                offset = 0;\n            }\n            return new Vector4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n        };\n        Vector4.FromArrayToRef = function (array, offset, result) {\n            result.x = array[offset];\n            result.y = array[offset + 1];\n            result.z = array[offset + 2];\n            result.w = array[offset + 3];\n        };\n        Vector4.FromFloatArrayToRef = function (array, offset, result) {\n            result.x = array[offset];\n            result.y = array[offset + 1];\n            result.z = array[offset + 2];\n            result.w = array[offset + 3];\n        };\n        Vector4.FromFloatsToRef = function (x, y, z, w, result) {\n            result.x = x;\n            result.y = y;\n            result.z = z;\n            result.w = w;\n        };\n        Vector4.Zero = function () {\n            return new Vector4(0, 0, 0, 0);\n        };\n        Vector4.Normalize = function (vector) {\n            var result = Vector4.Zero();\n            Vector4.NormalizeToRef(vector, result);\n            return result;\n        };\n        Vector4.NormalizeToRef = function (vector, result) {\n            result.copyFrom(vector);\n            result.normalize();\n        };\n        Vector4.Minimize = function (left, right) {\n            var min = left.clone();\n            min.MinimizeInPlace(right);\n            return min;\n        };\n        Vector4.Maximize = function (left, right) {\n            var max = left.clone();\n            max.MaximizeInPlace(right);\n            return max;\n        };\n        Vector4.Distance = function (value1, value2) {\n            return Math.sqrt(Vector4.DistanceSquared(value1, value2));\n        };\n        Vector4.DistanceSquared = function (value1, value2) {\n            var x = value1.x - value2.x;\n            var y = value1.y - value2.y;\n            var z = value1.z - value2.z;\n            var w = value1.w - value2.w;\n            return (x * x) + (y * y) + (z * z) + (w * w);\n        };\n        Vector4.Center = function (value1, value2) {\n            var center = value1.add(value2);\n            center.scaleInPlace(0.5);\n            return center;\n        };\n        return Vector4;\n    })();\n    BABYLON.Vector4 = Vector4;\n    var Quaternion = (function () {\n        function Quaternion(x, y, z, w) {\n            if (x === void 0) { x = 0; }\n            if (y === void 0) { y = 0; }\n            if (z === void 0) { z = 0; }\n            if (w === void 0) { w = 1; }\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            this.w = w;\n        }\n        Quaternion.prototype.toString = function () {\n            return \"{X: \" + this.x + \" Y:\" + this.y + \" Z:\" + this.z + \" W:\" + this.w + \"}\";\n        };\n        Quaternion.prototype.asArray = function () {\n            return [this.x, this.y, this.z, this.w];\n        };\n        Quaternion.prototype.equals = function (otherQuaternion) {\n            return otherQuaternion && this.x === otherQuaternion.x && this.y === otherQuaternion.y && this.z === otherQuaternion.z && this.w === otherQuaternion.w;\n        };\n        Quaternion.prototype.clone = function () {\n            return new Quaternion(this.x, this.y, this.z, this.w);\n        };\n        Quaternion.prototype.copyFrom = function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.z = other.z;\n            this.w = other.w;\n            return this;\n        };\n        Quaternion.prototype.copyFromFloats = function (x, y, z, w) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            this.w = w;\n            return this;\n        };\n        Quaternion.prototype.add = function (other) {\n            return new Quaternion(this.x + other.x, this.y + other.y, this.z + other.z, this.w + other.w);\n        };\n        Quaternion.prototype.subtract = function (other) {\n            return new Quaternion(this.x - other.x, this.y - other.y, this.z - other.z, this.w - other.w);\n        };\n        Quaternion.prototype.scale = function (value) {\n            return new Quaternion(this.x * value, this.y * value, this.z * value, this.w * value);\n        };\n        Quaternion.prototype.multiply = function (q1) {\n            var result = new Quaternion(0, 0, 0, 1.0);\n            this.multiplyToRef(q1, result);\n            return result;\n        };\n        Quaternion.prototype.multiplyToRef = function (q1, result) {\n            result.x = this.x * q1.w + this.y * q1.z - this.z * q1.y + this.w * q1.x;\n            result.y = -this.x * q1.z + this.y * q1.w + this.z * q1.x + this.w * q1.y;\n            result.z = this.x * q1.y - this.y * q1.x + this.z * q1.w + this.w * q1.z;\n            result.w = -this.x * q1.x - this.y * q1.y - this.z * q1.z + this.w * q1.w;\n            return this;\n        };\n        Quaternion.prototype.length = function () {\n            return Math.sqrt((this.x * this.x) + (this.y * this.y) + (this.z * this.z) + (this.w * this.w));\n        };\n        Quaternion.prototype.normalize = function () {\n            var length = 1.0 \/ this.length();\n            this.x *= length;\n            this.y *= length;\n            this.z *= length;\n            this.w *= length;\n            return this;\n        };\n        Quaternion.prototype.toEulerAngles = function () {\n            var result = Vector3.Zero();\n            this.toEulerAnglesToRef(result);\n            return result;\n        };\n        Quaternion.prototype.toEulerAnglesToRef = function (result) {\n            \/\/result is an EulerAngles in the in the z-x-z convention\n            var qx = this.x;\n            var qy = this.y;\n            var qz = this.z;\n            var qw = this.w;\n            var qxy = qx * qy;\n            var qxz = qx * qz;\n            var qwy = qw * qy;\n            var qwz = qw * qz;\n            var qwx = qw * qx;\n            var qyz = qy * qz;\n            var sqx = qx * qx;\n            var sqy = qy * qy;\n            var determinant = sqx + sqy;\n            if (determinant !== 0.000 && determinant !== 1.000) {\n                result.x = Math.atan2(qxz + qwy, qwx - qyz);\n                result.y = Math.acos(1 - 2 * determinant);\n                result.z = Math.atan2(qxz - qwy, qwx + qyz);\n            }\n            else {\n                if (determinant === 0.0) {\n                    result.x = 0.0;\n                    result.y = 0.0;\n                    result.z = Math.atan2(qxy - qwz, 0.5 - sqy - qz * qz); \/\/actually, degeneracy gives us choice with x+z=Math.atan2(qxy-qwz,0.5-sqy-qz*qz)\n                }\n                else {\n                    result.x = Math.atan2(qxy - qwz, 0.5 - sqy - qz * qz); \/\/actually, degeneracy gives us choice with x-z=Math.atan2(qxy-qwz,0.5-sqy-qz*qz)\n                    result.y = Math.PI;\n                    result.z = 0.0;\n                }\n            }\n            return this;\n        };\n        Quaternion.prototype.toRotationMatrix = function (result) {\n            var xx = this.x * this.x;\n            var yy = this.y * this.y;\n            var zz = this.z * this.z;\n            var xy = this.x * this.y;\n            var zw = this.z * this.w;\n            var zx = this.z * this.x;\n            var yw = this.y * this.w;\n            var yz = this.y * this.z;\n            var xw = this.x * this.w;\n            result.m[0] = 1.0 - (2.0 * (yy + zz));\n            result.m[1] = 2.0 * (xy + zw);\n            result.m[2] = 2.0 * (zx - yw);\n            result.m[3] = 0;\n            result.m[4] = 2.0 * (xy - zw);\n            result.m[5] = 1.0 - (2.0 * (zz + xx));\n            result.m[6] = 2.0 * (yz + xw);\n            result.m[7] = 0;\n            result.m[8] = 2.0 * (zx + yw);\n            result.m[9] = 2.0 * (yz - xw);\n            result.m[10] = 1.0 - (2.0 * (yy + xx));\n            result.m[11] = 0;\n            result.m[12] = 0;\n            result.m[13] = 0;\n            result.m[14] = 0;\n            result.m[15] = 1.0;\n            return this;\n        };\n        Quaternion.prototype.fromRotationMatrix = function (matrix) {\n            Quaternion.FromRotationMatrixToRef(matrix, this);\n            return this;\n        };\n        \/\/ Statics\n        Quaternion.FromRotationMatrix = function (matrix) {\n            var result = new Quaternion();\n            Quaternion.FromRotationMatrixToRef(matrix, result);\n            return result;\n        };\n        Quaternion.FromRotationMatrixToRef = function (matrix, result) {\n            var data = matrix.m;\n            var m11 = data[0], m12 = data[4], m13 = data[8];\n            var m21 = data[1], m22 = data[5], m23 = data[9];\n            var m31 = data[2], m32 = data[6], m33 = data[10];\n            var trace = m11 + m22 + m33;\n            var s;\n            if (trace > 0) {\n                s = 0.5 \/ Math.sqrt(trace + 1.0);\n                result.w = 0.25 \/ s;\n                result.x = (m32 - m23) * s;\n                result.y = (m13 - m31) * s;\n                result.z = (m21 - m12) * s;\n            }\n            else if (m11 > m22 && m11 > m33) {\n                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n                result.w = (m32 - m23) \/ s;\n                result.x = 0.25 * s;\n                result.y = (m12 + m21) \/ s;\n                result.z = (m13 + m31) \/ s;\n            }\n            else if (m22 > m33) {\n                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n                result.w = (m13 - m31) \/ s;\n                result.x = (m12 + m21) \/ s;\n                result.y = 0.25 * s;\n                result.z = (m23 + m32) \/ s;\n            }\n            else {\n                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n                result.w = (m21 - m12) \/ s;\n                result.x = (m13 + m31) \/ s;\n                result.y = (m23 + m32) \/ s;\n                result.z = 0.25 * s;\n            }\n        };\n        Quaternion.Inverse = function (q) {\n            return new Quaternion(-q.x, -q.y, -q.z, q.w);\n        };\n        Quaternion.Identity = function () {\n            return new Quaternion(0, 0, 0, 1);\n        };\n        Quaternion.RotationAxis = function (axis, angle) {\n            var result = new Quaternion();\n            var sin = Math.sin(angle \/ 2);\n            result.w = Math.cos(angle \/ 2);\n            result.x = axis.x * sin;\n            result.y = axis.y * sin;\n            result.z = axis.z * sin;\n            return result;\n        };\n        Quaternion.FromArray = function (array, offset) {\n            if (!offset) {\n                offset = 0;\n            }\n            return new Quaternion(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n        };\n        Quaternion.RotationYawPitchRoll = function (yaw, pitch, roll) {\n            var result = new Quaternion();\n            Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, result);\n            return result;\n        };\n        Quaternion.RotationYawPitchRollToRef = function (yaw, pitch, roll, result) {\n            \/\/ Produces a quaternion from Euler angles in the z-y-x orientation (Tait-Bryan angles)\n            var halfRoll = roll * 0.5;\n            var halfPitch = pitch * 0.5;\n            var halfYaw = yaw * 0.5;\n            var sinRoll = Math.sin(halfRoll);\n            var cosRoll = Math.cos(halfRoll);\n            var sinPitch = Math.sin(halfPitch);\n            var cosPitch = Math.cos(halfPitch);\n            var sinYaw = Math.sin(halfYaw);\n            var cosYaw = Math.cos(halfYaw);\n            result.x = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\n            result.y = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\n            result.z = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\n            result.w = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\n        };\n        Quaternion.RotationAlphaBetaGamma = function (alpha, beta, gamma) {\n            var result = new Quaternion();\n            Quaternion.RotationAlphaBetaGammaToRef(alpha, beta, gamma, result);\n            return result;\n        };\n        Quaternion.RotationAlphaBetaGammaToRef = function (alpha, beta, gamma, result) {\n            \/\/ Produces a quaternion from Euler angles in the z-x-z orientation\n            var halfGammaPlusAlpha = (gamma + alpha) * 0.5;\n            var halfGammaMinusAlpha = (gamma - alpha) * 0.5;\n            var halfBeta = beta * 0.5;\n            result.x = Math.cos(halfGammaMinusAlpha) * Math.sin(halfBeta);\n            result.y = Math.sin(halfGammaMinusAlpha) * Math.sin(halfBeta);\n            result.z = Math.sin(halfGammaPlusAlpha) * Math.cos(halfBeta);\n            result.w = Math.cos(halfGammaPlusAlpha) * Math.cos(halfBeta);\n        };\n        Quaternion.Slerp = function (left, right, amount) {\n            var num2;\n            var num3;\n            var num = amount;\n            var num4 = (((left.x * right.x) + (left.y * right.y)) + (left.z * right.z)) + (left.w * right.w);\n            var flag = false;\n            if (num4 < 0) {\n                flag = true;\n                num4 = -num4;\n            }\n            if (num4 > 0.999999) {\n                num3 = 1 - num;\n                num2 = flag ? -num : num;\n            }\n            else {\n                var num5 = Math.acos(num4);\n                var num6 = (1.0 \/ Math.sin(num5));\n                num3 = (Math.sin((1.0 - num) * num5)) * num6;\n                num2 = flag ? ((-Math.sin(num * num5)) * num6) : ((Math.sin(num * num5)) * num6);\n            }\n            return new Quaternion((num3 * left.x) + (num2 * right.x), (num3 * left.y) + (num2 * right.y), (num3 * left.z) + (num2 * right.z), (num3 * left.w) + (num2 * right.w));\n        };\n        return Quaternion;\n    })();\n    BABYLON.Quaternion = Quaternion;\n    var Matrix = (function () {\n        function Matrix() {\n            this.m = new Float32Array(16);\n        }\n        \/\/ Properties\n        Matrix.prototype.isIdentity = function () {\n            if (this.m[0] !== 1.0 || this.m[5] !== 1.0 || this.m[10] !== 1.0 || this.m[15] !== 1.0)\n                return false;\n            if (this.m[1] !== 0.0 || this.m[2] !== 0.0 || this.m[3] !== 0.0 || this.m[4] !== 0.0 || this.m[6] !== 0.0 || this.m[7] !== 0.0 || this.m[8] !== 0.0 || this.m[9] !== 0.0 || this.m[11] !== 0.0 || this.m[12] !== 0.0 || this.m[13] !== 0.0 || this.m[14] !== 0.0)\n                return false;\n            return true;\n        };\n        Matrix.prototype.determinant = function () {\n            var temp1 = (this.m[10] * this.m[15]) - (this.m[11] * this.m[14]);\n            var temp2 = (this.m[9] * this.m[15]) - (this.m[11] * this.m[13]);\n            var temp3 = (this.m[9] * this.m[14]) - (this.m[10] * this.m[13]);\n            var temp4 = (this.m[8] * this.m[15]) - (this.m[11] * this.m[12]);\n            var temp5 = (this.m[8] * this.m[14]) - (this.m[10] * this.m[12]);\n            var temp6 = (this.m[8] * this.m[13]) - (this.m[9] * this.m[12]);\n            return ((((this.m[0] * (((this.m[5] * temp1) - (this.m[6] * temp2)) + (this.m[7] * temp3))) - (this.m[1] * (((this.m[4] * temp1) - (this.m[6] * temp4)) + (this.m[7] * temp5)))) + (this.m[2] * (((this.m[4] * temp2) - (this.m[5] * temp4)) + (this.m[7] * temp6)))) - (this.m[3] * (((this.m[4] * temp3) - (this.m[5] * temp5)) + (this.m[6] * temp6))));\n        };\n        \/\/ Methods\n        Matrix.prototype.toArray = function () {\n            return this.m;\n        };\n        Matrix.prototype.asArray = function () {\n            return this.toArray();\n        };\n        Matrix.prototype.invert = function () {\n            this.invertToRef(this);\n            return this;\n        };\n        Matrix.prototype.invertToRef = function (other) {\n            var l1 = this.m[0];\n            var l2 = this.m[1];\n            var l3 = this.m[2];\n            var l4 = this.m[3];\n            var l5 = this.m[4];\n            var l6 = this.m[5];\n            var l7 = this.m[6];\n            var l8 = this.m[7];\n            var l9 = this.m[8];\n            var l10 = this.m[9];\n            var l11 = this.m[10];\n            var l12 = this.m[11];\n            var l13 = this.m[12];\n            var l14 = this.m[13];\n            var l15 = this.m[14];\n            var l16 = this.m[15];\n            var l17 = (l11 * l16) - (l12 * l15);\n            var l18 = (l10 * l16) - (l12 * l14);\n            var l19 = (l10 * l15) - (l11 * l14);\n            var l20 = (l9 * l16) - (l12 * l13);\n            var l21 = (l9 * l15) - (l11 * l13);\n            var l22 = (l9 * l14) - (l10 * l13);\n            var l23 = ((l6 * l17) - (l7 * l18)) + (l8 * l19);\n            var l24 = -(((l5 * l17) - (l7 * l20)) + (l8 * l21));\n            var l25 = ((l5 * l18) - (l6 * l20)) + (l8 * l22);\n            var l26 = -(((l5 * l19) - (l6 * l21)) + (l7 * l22));\n            var l27 = 1.0 \/ ((((l1 * l23) + (l2 * l24)) + (l3 * l25)) + (l4 * l26));\n            var l28 = (l7 * l16) - (l8 * l15);\n            var l29 = (l6 * l16) - (l8 * l14);\n            var l30 = (l6 * l15) - (l7 * l14);\n            var l31 = (l5 * l16) - (l8 * l13);\n            var l32 = (l5 * l15) - (l7 * l13);\n            var l33 = (l5 * l14) - (l6 * l13);\n            var l34 = (l7 * l12) - (l8 * l11);\n            var l35 = (l6 * l12) - (l8 * l10);\n            var l36 = (l6 * l11) - (l7 * l10);\n            var l37 = (l5 * l12) - (l8 * l9);\n            var l38 = (l5 * l11) - (l7 * l9);\n            var l39 = (l5 * l10) - (l6 * l9);\n            other.m[0] = l23 * l27;\n            other.m[4] = l24 * l27;\n            other.m[8] = l25 * l27;\n            other.m[12] = l26 * l27;\n            other.m[1] = -(((l2 * l17) - (l3 * l18)) + (l4 * l19)) * l27;\n            other.m[5] = (((l1 * l17) - (l3 * l20)) + (l4 * l21)) * l27;\n            other.m[9] = -(((l1 * l18) - (l2 * l20)) + (l4 * l22)) * l27;\n            other.m[13] = (((l1 * l19) - (l2 * l21)) + (l3 * l22)) * l27;\n            other.m[2] = (((l2 * l28) - (l3 * l29)) + (l4 * l30)) * l27;\n            other.m[6] = -(((l1 * l28) - (l3 * l31)) + (l4 * l32)) * l27;\n            other.m[10] = (((l1 * l29) - (l2 * l31)) + (l4 * l33)) * l27;\n            other.m[14] = -(((l1 * l30) - (l2 * l32)) + (l3 * l33)) * l27;\n            other.m[3] = -(((l2 * l34) - (l3 * l35)) + (l4 * l36)) * l27;\n            other.m[7] = (((l1 * l34) - (l3 * l37)) + (l4 * l38)) * l27;\n            other.m[11] = -(((l1 * l35) - (l2 * l37)) + (l4 * l39)) * l27;\n            other.m[15] = (((l1 * l36) - (l2 * l38)) + (l3 * l39)) * l27;\n            return this;\n        };\n        Matrix.prototype.invertToRefSIMD = function (other) {\n            var src = this.m;\n            var dest = other.m;\n            var row0, row1, row2, row3;\n            var tmp1;\n            var minor0, minor1, minor2, minor3;\n            var det;\n            \/\/ Load the 4 rows\n            var src0 = SIMD.float32x4.load(src, 0);\n            var src1 = SIMD.float32x4.load(src, 4);\n            var src2 = SIMD.float32x4.load(src, 8);\n            var src3 = SIMD.float32x4.load(src, 12);\n            \/\/ Transpose the source matrix.  Sort of.  Not a true transpose operation\n            tmp1 = SIMD.float32x4.shuffle(src0, src1, 0, 1, 4, 5);\n            row1 = SIMD.float32x4.shuffle(src2, src3, 0, 1, 4, 5);\n            row0 = SIMD.float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);\n            row1 = SIMD.float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);\n            tmp1 = SIMD.float32x4.shuffle(src0, src1, 2, 3, 6, 7);\n            row3 = SIMD.float32x4.shuffle(src2, src3, 2, 3, 6, 7);\n            row2 = SIMD.float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);\n            row3 = SIMD.float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);\n            \/\/ This is a true transposition, but it will lead to an incorrect result\n            \/\/tmp1 = SIMD.float32x4.shuffle(src0, src1, 0, 1, 4, 5);\n            \/\/tmp2 = SIMD.float32x4.shuffle(src2, src3, 0, 1, 4, 5);\n            \/\/row0  = SIMD.float32x4.shuffle(tmp1, tmp2, 0, 2, 4, 6);\n            \/\/row1  = SIMD.float32x4.shuffle(tmp1, tmp2, 1, 3, 5, 7);\n            \/\/tmp1 = SIMD.float32x4.shuffle(src0, src1, 2, 3, 6, 7);\n            \/\/tmp2 = SIMD.float32x4.shuffle(src2, src3, 2, 3, 6, 7);\n            \/\/row2  = SIMD.float32x4.shuffle(tmp1, tmp2, 0, 2, 4, 6);\n            \/\/row3  = SIMD.float32x4.shuffle(tmp1, tmp2, 1, 3, 5, 7);\n            \/\/ ----\n            tmp1 = SIMD.float32x4.mul(row2, row3);\n            tmp1 = SIMD.float32x4.swizzle(tmp1, 1, 0, 3, 2); \/\/ 0xB1 = 10110001\n            minor0 = SIMD.float32x4.mul(row1, tmp1);\n            minor1 = SIMD.float32x4.mul(row0, tmp1);\n            tmp1 = SIMD.float32x4.swizzle(tmp1, 2, 3, 0, 1); \/\/ 0x4E = 01001110\n            minor0 = SIMD.float32x4.sub(SIMD.float32x4.mul(row1, tmp1), minor0);\n            minor1 = SIMD.float32x4.sub(SIMD.float32x4.mul(row0, tmp1), minor1);\n            minor1 = SIMD.float32x4.swizzle(minor1, 2, 3, 0, 1); \/\/ 0x4E = 01001110\n            \/\/ ----\n            tmp1 = SIMD.float32x4.mul(row1, row2);\n            tmp1 = SIMD.float32x4.swizzle(tmp1, 1, 0, 3, 2); \/\/ 0xB1 = 10110001\n            minor0 = SIMD.float32x4.add(SIMD.float32x4.mul(row3, tmp1), minor0);\n            minor3 = SIMD.float32x4.mul(row0, tmp1);\n            tmp1 = SIMD.float32x4.swizzle(tmp1, 2, 3, 0, 1); \/\/ 0x4E = 01001110\n            minor0 = SIMD.float32x4.sub(minor0, SIMD.float32x4.mul(row3, tmp1));\n            minor3 = SIMD.float32x4.sub(SIMD.float32x4.mul(row0, tmp1), minor3);\n            minor3 = SIMD.float32x4.swizzle(minor3, 2, 3, 0, 1); \/\/ 0x4E = 01001110\n            \/\/ ----\n            tmp1 = SIMD.float32x4.mul(SIMD.float32x4.swizzle(row1, 2, 3, 0, 1), row3); \/\/ 0x4E = 01001110\n            tmp1 = SIMD.float32x4.swizzle(tmp1, 1, 0, 3, 2); \/\/ 0xB1 = 10110001\n            row2 = SIMD.float32x4.swizzle(row2, 2, 3, 0, 1); \/\/ 0x4E = 01001110\n            minor0 = SIMD.float32x4.add(SIMD.float32x4.mul(row2, tmp1), minor0);\n            minor2 = SIMD.float32x4.mul(row0, tmp1);\n            tmp1 = SIMD.float32x4.swizzle(tmp1, 2, 3, 0, 1); \/\/ 0x4E = 01001110\n            minor0 = SIMD.float32x4.sub(minor0, SIMD.float32x4.mul(row2, tmp1));\n            minor2 = SIMD.float32x4.sub(SIMD.float32x4.mul(row0, tmp1), minor2);\n            minor2 = SIMD.float32x4.swizzle(minor2, 2, 3, 0, 1); \/\/ 0x4E = 01001110\n            \/\/ ----\n            tmp1 = SIMD.float32x4.mul(row0, row1);\n            tmp1 = SIMD.float32x4.swizzle(tmp1, 1, 0, 3, 2); \/\/ 0xB1 = 10110001\n            minor2 = SIMD.float32x4.add(SIMD.float32x4.mul(row3, tmp1), minor2);\n            minor3 = SIMD.float32x4.sub(SIMD.float32x4.mul(row2, tmp1), minor3);\n            tmp1 = SIMD.float32x4.swizzle(tmp1, 2, 3, 0, 1); \/\/ 0x4E = 01001110\n            minor2 = SIMD.float32x4.sub(SIMD.float32x4.mul(row3, tmp1), minor2);\n            minor3 = SIMD.float32x4.sub(minor3, SIMD.float32x4.mul(row2, tmp1));\n            \/\/ ----\n            tmp1 = SIMD.float32x4.mul(row0, row3);\n            tmp1 = SIMD.float32x4.swizzle(tmp1, 1, 0, 3, 2); \/\/ 0xB1 = 10110001\n            minor1 = SIMD.float32x4.sub(minor1, SIMD.float32x4.mul(row2, tmp1));\n            minor2 = SIMD.float32x4.add(SIMD.float32x4.mul(row1, tmp1), minor2);\n            tmp1 = SIMD.float32x4.swizzle(tmp1, 2, 3, 0, 1); \/\/ 0x4E = 01001110\n            minor1 = SIMD.float32x4.add(SIMD.float32x4.mul(row2, tmp1), minor1);\n            minor2 = SIMD.float32x4.sub(minor2, SIMD.float32x4.mul(row1, tmp1));\n            \/\/ ----\n            tmp1 = SIMD.float32x4.mul(row0, row2);\n            tmp1 = SIMD.float32x4.swizzle(tmp1, 1, 0, 3, 2); \/\/ 0xB1 = 10110001\n            minor1 = SIMD.float32x4.add(SIMD.float32x4.mul(row3, tmp1), minor1);\n            minor3 = SIMD.float32x4.sub(minor3, SIMD.float32x4.mul(row1, tmp1));\n            tmp1 = SIMD.float32x4.swizzle(tmp1, 2, 3, 0, 1); \/\/ 0x4E = 01001110\n            minor1 = SIMD.float32x4.sub(minor1, SIMD.float32x4.mul(row3, tmp1));\n            minor3 = SIMD.float32x4.add(SIMD.float32x4.mul(row1, tmp1), minor3);\n            \/\/ Compute determinant\n            det = SIMD.float32x4.mul(row0, minor0);\n            det = SIMD.float32x4.add(SIMD.float32x4.swizzle(det, 2, 3, 0, 1), det); \/\/ 0x4E = 01001110\n            det = SIMD.float32x4.add(SIMD.float32x4.swizzle(det, 1, 0, 3, 2), det); \/\/ 0xB1 = 10110001\n            tmp1 = SIMD.float32x4.reciprocalApproximation(det);\n            det = SIMD.float32x4.sub(SIMD.float32x4.add(tmp1, tmp1), SIMD.float32x4.mul(det, SIMD.float32x4.mul(tmp1, tmp1)));\n            det = SIMD.float32x4.swizzle(det, 0, 0, 0, 0);\n            \/\/ These shuffles aren\'t necessary if the faulty transposition is done\n            \/\/ up at the top of this function.\n            \/\/minor0 = SIMD.float32x4.swizzle(minor0, 2, 1, 0, 3);\n            \/\/minor1 = SIMD.float32x4.swizzle(minor1, 2, 1, 0, 3);\n            \/\/minor2 = SIMD.float32x4.swizzle(minor2, 2, 1, 0, 3);\n            \/\/minor3 = SIMD.float32x4.swizzle(minor3, 2, 1, 0, 3);\n            \/\/ Compute final values by multiplying with 1\/det\n            minor0 = SIMD.float32x4.mul(det, minor0);\n            minor1 = SIMD.float32x4.mul(det, minor1);\n            minor2 = SIMD.float32x4.mul(det, minor2);\n            minor3 = SIMD.float32x4.mul(det, minor3);\n            SIMD.float32x4.store(dest, 0, minor0);\n            SIMD.float32x4.store(dest, 4, minor1);\n            SIMD.float32x4.store(dest, 8, minor2);\n            SIMD.float32x4.store(dest, 12, minor3);\n            return this;\n        };\n        Matrix.prototype.setTranslation = function (vector3) {\n            this.m[12] = vector3.x;\n            this.m[13] = vector3.y;\n            this.m[14] = vector3.z;\n            return this;\n        };\n        Matrix.prototype.multiply = function (other) {\n            var result = new Matrix();\n            this.multiplyToRef(other, result);\n            return result;\n        };\n        Matrix.prototype.copyFrom = function (other) {\n            for (var index = 0; index < 16; index++) {\n                this.m[index] = other.m[index];\n            }\n            return this;\n        };\n        Matrix.prototype.copyToArray = function (array, offset) {\n            if (offset === void 0) { offset = 0; }\n            for (var index = 0; index < 16; index++) {\n                array[offset + index] = this.m[index];\n            }\n            return this;\n        };\n        Matrix.prototype.multiplyToRef = function (other, result) {\n            this.multiplyToArray(other, result.m, 0);\n            return this;\n        };\n        Matrix.prototype.multiplyToArray = function (other, result, offset) {\n            var tm0 = this.m[0];\n            var tm1 = this.m[1];\n            var tm2 = this.m[2];\n            var tm3 = this.m[3];\n            var tm4 = this.m[4];\n            var tm5 = this.m[5];\n            var tm6 = this.m[6];\n            var tm7 = this.m[7];\n            var tm8 = this.m[8];\n            var tm9 = this.m[9];\n            var tm10 = this.m[10];\n            var tm11 = this.m[11];\n            var tm12 = this.m[12];\n            var tm13 = this.m[13];\n            var tm14 = this.m[14];\n            var tm15 = this.m[15];\n            var om0 = other.m[0];\n            var om1 = other.m[1];\n            var om2 = other.m[2];\n            var om3 = other.m[3];\n            var om4 = other.m[4];\n            var om5 = other.m[5];\n            var om6 = other.m[6];\n            var om7 = other.m[7];\n            var om8 = other.m[8];\n            var om9 = other.m[9];\n            var om10 = other.m[10];\n            var om11 = other.m[11];\n            var om12 = other.m[12];\n            var om13 = other.m[13];\n            var om14 = other.m[14];\n            var om15 = other.m[15];\n            result[offset] = tm0 * om0 + tm1 * om4 + tm2 * om8 + tm3 * om12;\n            result[offset + 1] = tm0 * om1 + tm1 * om5 + tm2 * om9 + tm3 * om13;\n            result[offset + 2] = tm0 * om2 + tm1 * om6 + tm2 * om10 + tm3 * om14;\n            result[offset + 3] = tm0 * om3 + tm1 * om7 + tm2 * om11 + tm3 * om15;\n            result[offset + 4] = tm4 * om0 + tm5 * om4 + tm6 * om8 + tm7 * om12;\n            result[offset + 5] = tm4 * om1 + tm5 * om5 + tm6 * om9 + tm7 * om13;\n            result[offset + 6] = tm4 * om2 + tm5 * om6 + tm6 * om10 + tm7 * om14;\n            result[offset + 7] = tm4 * om3 + tm5 * om7 + tm6 * om11 + tm7 * om15;\n            result[offset + 8] = tm8 * om0 + tm9 * om4 + tm10 * om8 + tm11 * om12;\n            result[offset + 9] = tm8 * om1 + tm9 * om5 + tm10 * om9 + tm11 * om13;\n            result[offset + 10] = tm8 * om2 + tm9 * om6 + tm10 * om10 + tm11 * om14;\n            result[offset + 11] = tm8 * om3 + tm9 * om7 + tm10 * om11 + tm11 * om15;\n            result[offset + 12] = tm12 * om0 + tm13 * om4 + tm14 * om8 + tm15 * om12;\n            result[offset + 13] = tm12 * om1 + tm13 * om5 + tm14 * om9 + tm15 * om13;\n            result[offset + 14] = tm12 * om2 + tm13 * om6 + tm14 * om10 + tm15 * om14;\n            result[offset + 15] = tm12 * om3 + tm13 * om7 + tm14 * om11 + tm15 * om15;\n            return this;\n        };\n        Matrix.prototype.multiplyToArraySIMD = function (other, result, offset) {\n            if (offset === void 0) { offset = 0; }\n            var tm = this.m;\n            var om = other.m;\n            var om0 = SIMD.float32x4.load(om, 0);\n            var om1 = SIMD.float32x4.load(om, 4);\n            var om2 = SIMD.float32x4.load(om, 8);\n            var om3 = SIMD.float32x4.load(om, 12);\n            var tm0 = SIMD.float32x4.load(tm, 0);\n            SIMD.float32x4.store(result, offset + 0, SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(tm0, 0, 0, 0, 0), om0), SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(tm0, 1, 1, 1, 1), om1), SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(tm0, 2, 2, 2, 2), om2), SIMD.float32x4.mul(SIMD.float32x4.swizzle(tm0, 3, 3, 3, 3), om3)))));\n            var tm1 = SIMD.float32x4.load(tm, 4);\n            SIMD.float32x4.store(result, offset + 4, SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(tm1, 0, 0, 0, 0), om0), SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(tm1, 1, 1, 1, 1), om1), SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(tm1, 2, 2, 2, 2), om2), SIMD.float32x4.mul(SIMD.float32x4.swizzle(tm1, 3, 3, 3, 3), om3)))));\n            var tm2 = SIMD.float32x4.load(tm, 8);\n            SIMD.float32x4.store(result, offset + 8, SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(tm2, 0, 0, 0, 0), om0), SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(tm2, 1, 1, 1, 1), om1), SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(tm2, 2, 2, 2, 2), om2), SIMD.float32x4.mul(SIMD.float32x4.swizzle(tm2, 3, 3, 3, 3), om3)))));\n            var tm3 = SIMD.float32x4.load(tm, 12);\n            SIMD.float32x4.store(result, offset + 12, SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(tm3, 0, 0, 0, 0), om0), SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(tm3, 1, 1, 1, 1), om1), SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(tm3, 2, 2, 2, 2), om2), SIMD.float32x4.mul(SIMD.float32x4.swizzle(tm3, 3, 3, 3, 3), om3)))));\n        };\n        Matrix.prototype.equals = function (value) {\n            return value && (this.m[0] === value.m[0] && this.m[1] === value.m[1] && this.m[2] === value.m[2] && this.m[3] === value.m[3] && this.m[4] === value.m[4] && this.m[5] === value.m[5] && this.m[6] === value.m[6] && this.m[7] === value.m[7] && this.m[8] === value.m[8] && this.m[9] === value.m[9] && this.m[10] === value.m[10] && this.m[11] === value.m[11] && this.m[12] === value.m[12] && this.m[13] === value.m[13] && this.m[14] === value.m[14] && this.m[15] === value.m[15]);\n        };\n        Matrix.prototype.clone = function () {\n            return Matrix.FromValues(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5], this.m[6], this.m[7], this.m[8], this.m[9], this.m[10], this.m[11], this.m[12], this.m[13], this.m[14], this.m[15]);\n        };\n        Matrix.prototype.decompose = function (scale, rotation, translation) {\n            translation.x = this.m[12];\n            translation.y = this.m[13];\n            translation.z = this.m[14];\n            var xs = BABYLON.Tools.Sign(this.m[0] * this.m[1] * this.m[2] * this.m[3]) < 0 ? -1 : 1;\n            var ys = BABYLON.Tools.Sign(this.m[4] * this.m[5] * this.m[6] * this.m[7]) < 0 ? -1 : 1;\n            var zs = BABYLON.Tools.Sign(this.m[8] * this.m[9] * this.m[10] * this.m[11]) < 0 ? -1 : 1;\n            scale.x = xs * Math.sqrt(this.m[0] * this.m[0] + this.m[1] * this.m[1] + this.m[2] * this.m[2]);\n            scale.y = ys * Math.sqrt(this.m[4] * this.m[4] + this.m[5] * this.m[5] + this.m[6] * this.m[6]);\n            scale.z = zs * Math.sqrt(this.m[8] * this.m[8] + this.m[9] * this.m[9] + this.m[10] * this.m[10]);\n            if (scale.x === 0 || scale.y === 0 || scale.z === 0) {\n                rotation.x = 0;\n                rotation.y = 0;\n                rotation.z = 0;\n                rotation.w = 1;\n                return false;\n            }\n            var rotationMatrix = Matrix.FromValues(this.m[0] \/ scale.x, this.m[1] \/ scale.x, this.m[2] \/ scale.x, 0, this.m[4] \/ scale.y, this.m[5] \/ scale.y, this.m[6] \/ scale.y, 0, this.m[8] \/ scale.z, this.m[9] \/ scale.z, this.m[10] \/ scale.z, 0, 0, 0, 0, 1);\n            Quaternion.FromRotationMatrixToRef(rotationMatrix, rotation);\n            return true;\n        };\n        \/\/ Statics\n        Matrix.FromArray = function (array, offset) {\n            var result = new Matrix();\n            if (!offset) {\n                offset = 0;\n            }\n            Matrix.FromArrayToRef(array, offset, result);\n            return result;\n        };\n        Matrix.FromArrayToRef = function (array, offset, result) {\n            for (var index = 0; index < 16; index++) {\n                result.m[index] = array[index + offset];\n            }\n        };\n        Matrix.FromValuesToRef = function (initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44, result) {\n            result.m[0] = initialM11;\n            result.m[1] = initialM12;\n            result.m[2] = initialM13;\n            result.m[3] = initialM14;\n            result.m[4] = initialM21;\n            result.m[5] = initialM22;\n            result.m[6] = initialM23;\n            result.m[7] = initialM24;\n            result.m[8] = initialM31;\n            result.m[9] = initialM32;\n            result.m[10] = initialM33;\n            result.m[11] = initialM34;\n            result.m[12] = initialM41;\n            result.m[13] = initialM42;\n            result.m[14] = initialM43;\n            result.m[15] = initialM44;\n        };\n        Matrix.FromValues = function (initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44) {\n            var result = new Matrix();\n            result.m[0] = initialM11;\n            result.m[1] = initialM12;\n            result.m[2] = initialM13;\n            result.m[3] = initialM14;\n            result.m[4] = initialM21;\n            result.m[5] = initialM22;\n            result.m[6] = initialM23;\n            result.m[7] = initialM24;\n            result.m[8] = initialM31;\n            result.m[9] = initialM32;\n            result.m[10] = initialM33;\n            result.m[11] = initialM34;\n            result.m[12] = initialM41;\n            result.m[13] = initialM42;\n            result.m[14] = initialM43;\n            result.m[15] = initialM44;\n            return result;\n        };\n        Matrix.Compose = function (scale, rotation, translation) {\n            var result = Matrix.FromValues(scale.x, 0, 0, 0, 0, scale.y, 0, 0, 0, 0, scale.z, 0, 0, 0, 0, 1);\n            var rotationMatrix = Matrix.Identity();\n            rotation.toRotationMatrix(rotationMatrix);\n            result = result.multiply(rotationMatrix);\n            result.setTranslation(translation);\n            return result;\n        };\n        Matrix.Identity = function () {\n            return Matrix.FromValues(1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0);\n        };\n        Matrix.IdentityToRef = function (result) {\n            Matrix.FromValuesToRef(1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0, result);\n        };\n        Matrix.Zero = function () {\n            return Matrix.FromValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n        };\n        Matrix.RotationX = function (angle) {\n            var result = new Matrix();\n            Matrix.RotationXToRef(angle, result);\n            return result;\n        };\n        Matrix.Invert = function (source) {\n            var result = new Matrix();\n            source.invertToRef(result);\n            return result;\n        };\n        Matrix.RotationXToRef = function (angle, result) {\n            var s = Math.sin(angle);\n            var c = Math.cos(angle);\n            result.m[0] = 1.0;\n            result.m[15] = 1.0;\n            result.m[5] = c;\n            result.m[10] = c;\n            result.m[9] = -s;\n            result.m[6] = s;\n            result.m[1] = 0;\n            result.m[2] = 0;\n            result.m[3] = 0;\n            result.m[4] = 0;\n            result.m[7] = 0;\n            result.m[8] = 0;\n            result.m[11] = 0;\n            result.m[12] = 0;\n            result.m[13] = 0;\n            result.m[14] = 0;\n        };\n        Matrix.RotationY = function (angle) {\n            var result = new Matrix();\n            Matrix.RotationYToRef(angle, result);\n            return result;\n        };\n        Matrix.RotationYToRef = function (angle, result) {\n            var s = Math.sin(angle);\n            var c = Math.cos(angle);\n            result.m[5] = 1.0;\n            result.m[15] = 1.0;\n            result.m[0] = c;\n            result.m[2] = -s;\n            result.m[8] = s;\n            result.m[10] = c;\n            result.m[1] = 0;\n            result.m[3] = 0;\n            result.m[4] = 0;\n            result.m[6] = 0;\n            result.m[7] = 0;\n            result.m[9] = 0;\n            result.m[11] = 0;\n            result.m[12] = 0;\n            result.m[13] = 0;\n            result.m[14] = 0;\n        };\n        Matrix.RotationZ = function (angle) {\n            var result = new Matrix();\n            Matrix.RotationZToRef(angle, result);\n            return result;\n        };\n        Matrix.RotationZToRef = function (angle, result) {\n            var s = Math.sin(angle);\n            var c = Math.cos(angle);\n            result.m[10] = 1.0;\n            result.m[15] = 1.0;\n            result.m[0] = c;\n            result.m[1] = s;\n            result.m[4] = -s;\n            result.m[5] = c;\n            result.m[2] = 0;\n            result.m[3] = 0;\n            result.m[6] = 0;\n            result.m[7] = 0;\n            result.m[8] = 0;\n            result.m[9] = 0;\n            result.m[11] = 0;\n            result.m[12] = 0;\n            result.m[13] = 0;\n            result.m[14] = 0;\n        };\n        Matrix.RotationAxis = function (axis, angle) {\n            var s = Math.sin(-angle);\n            var c = Math.cos(-angle);\n            var c1 = 1 - c;\n            axis.normalize();\n            var result = Matrix.Zero();\n            result.m[0] = (axis.x * axis.x) * c1 + c;\n            result.m[1] = (axis.x * axis.y) * c1 - (axis.z * s);\n            result.m[2] = (axis.x * axis.z) * c1 + (axis.y * s);\n            result.m[3] = 0.0;\n            result.m[4] = (axis.y * axis.x) * c1 + (axis.z * s);\n            result.m[5] = (axis.y * axis.y) * c1 + c;\n            result.m[6] = (axis.y * axis.z) * c1 - (axis.x * s);\n            result.m[7] = 0.0;\n            result.m[8] = (axis.z * axis.x) * c1 - (axis.y * s);\n            result.m[9] = (axis.z * axis.y) * c1 + (axis.x * s);\n            result.m[10] = (axis.z * axis.z) * c1 + c;\n            result.m[11] = 0.0;\n            result.m[15] = 1.0;\n            return result;\n        };\n        Matrix.RotationYawPitchRoll = function (yaw, pitch, roll) {\n            var result = new Matrix();\n            Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, result);\n            return result;\n        };\n        Matrix.RotationYawPitchRollToRef = function (yaw, pitch, roll, result) {\n            Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, this._tempQuaternion);\n            this._tempQuaternion.toRotationMatrix(result);\n        };\n        Matrix.Scaling = function (x, y, z) {\n            var result = Matrix.Zero();\n            Matrix.ScalingToRef(x, y, z, result);\n            return result;\n        };\n        Matrix.ScalingToRef = function (x, y, z, result) {\n            result.m[0] = x;\n            result.m[1] = 0;\n            result.m[2] = 0;\n            result.m[3] = 0;\n            result.m[4] = 0;\n            result.m[5] = y;\n            result.m[6] = 0;\n            result.m[7] = 0;\n            result.m[8] = 0;\n            result.m[9] = 0;\n            result.m[10] = z;\n            result.m[11] = 0;\n            result.m[12] = 0;\n            result.m[13] = 0;\n            result.m[14] = 0;\n            result.m[15] = 1.0;\n        };\n        Matrix.Translation = function (x, y, z) {\n            var result = Matrix.Identity();\n            Matrix.TranslationToRef(x, y, z, result);\n            return result;\n        };\n        Matrix.TranslationToRef = function (x, y, z, result) {\n            Matrix.FromValuesToRef(1.0, 0, 0, 0, 0, 1.0, 0, 0, 0, 0, 1.0, 0, x, y, z, 1.0, result);\n        };\n        Matrix.LookAtLH = function (eye, target, up) {\n            var result = Matrix.Zero();\n            Matrix.LookAtLHToRef(eye, target, up, result);\n            return result;\n        };\n        Matrix.LookAtLHToRef = function (eye, target, up, result) {\n            \/\/ Z axis\n            target.subtractToRef(eye, this._zAxis);\n            this._zAxis.normalize();\n            \/\/ X axis\n            Vector3.CrossToRef(up, this._zAxis, this._xAxis);\n            this._xAxis.normalize();\n            \/\/ Y axis\n            Vector3.CrossToRef(this._zAxis, this._xAxis, this._yAxis);\n            this._yAxis.normalize();\n            \/\/ Eye angles\n            var ex = -Vector3.Dot(this._xAxis, eye);\n            var ey = -Vector3.Dot(this._yAxis, eye);\n            var ez = -Vector3.Dot(this._zAxis, eye);\n            return Matrix.FromValuesToRef(this._xAxis.x, this._yAxis.x, this._zAxis.x, 0, this._xAxis.y, this._yAxis.y, this._zAxis.y, 0, this._xAxis.z, this._yAxis.z, this._zAxis.z, 0, ex, ey, ez, 1, result);\n        };\n        Matrix.LookAtLHToRefSIMD = function (eyeRef, targetRef, upRef, result) {\n            var out = result.m;\n            var center = SIMD.float32x4(targetRef.x, targetRef.y, targetRef.z, 0);\n            var eye = SIMD.float32x4(eyeRef.x, eyeRef.y, eyeRef.z, 0);\n            var up = SIMD.float32x4(upRef.x, upRef.y, upRef.z, 0);\n            \/\/ cc.kmVec3Subtract(f, pCenter, pEye);\n            var f = SIMD.float32x4.sub(center, eye);\n            \/\/ cc.kmVec3Normalize(f, f);    \n            var tmp = SIMD.float32x4.mul(f, f);\n            tmp = SIMD.float32x4.add(tmp, SIMD.float32x4.add(SIMD.float32x4.swizzle(tmp, 1, 2, 0, 3), SIMD.float32x4.swizzle(tmp, 2, 0, 1, 3)));\n            f = SIMD.float32x4.mul(f, SIMD.float32x4.reciprocalSqrtApproximation(tmp));\n            \/\/ cc.kmVec3Assign(up, pUp);\n            \/\/ cc.kmVec3Normalize(up, up);\n            tmp = SIMD.float32x4.mul(up, up);\n            tmp = SIMD.float32x4.add(tmp, SIMD.float32x4.add(SIMD.float32x4.swizzle(tmp, 1, 2, 0, 3), SIMD.float32x4.swizzle(tmp, 2, 0, 1, 3)));\n            up = SIMD.float32x4.mul(up, SIMD.float32x4.reciprocalSqrtApproximation(tmp));\n            \/\/ cc.kmVec3Cross(s, f, up);\n            var s = SIMD.float32x4.sub(SIMD.float32x4.mul(SIMD.float32x4.swizzle(f, 1, 2, 0, 3), SIMD.float32x4.swizzle(up, 2, 0, 1, 3)), SIMD.float32x4.mul(SIMD.float32x4.swizzle(f, 2, 0, 1, 3), SIMD.float32x4.swizzle(up, 1, 2, 0, 3)));\n            \/\/ cc.kmVec3Normalize(s, s);\n            tmp = SIMD.float32x4.mul(s, s);\n            tmp = SIMD.float32x4.add(tmp, SIMD.float32x4.add(SIMD.float32x4.swizzle(tmp, 1, 2, 0, 3), SIMD.float32x4.swizzle(tmp, 2, 0, 1, 3)));\n            s = SIMD.float32x4.mul(s, SIMD.float32x4.reciprocalSqrtApproximation(tmp));\n            \/\/ cc.kmVec3Cross(u, s, f);\n            var u = SIMD.float32x4.sub(SIMD.float32x4.mul(SIMD.float32x4.swizzle(s, 1, 2, 0, 3), SIMD.float32x4.swizzle(f, 2, 0, 1, 3)), SIMD.float32x4.mul(SIMD.float32x4.swizzle(s, 2, 0, 1, 3), SIMD.float32x4.swizzle(f, 1, 2, 0, 3)));\n            \/\/ cc.kmVec3Normalize(s, s);\n            tmp = SIMD.float32x4.mul(s, s);\n            tmp = SIMD.float32x4.add(tmp, SIMD.float32x4.add(SIMD.float32x4.swizzle(tmp, 1, 2, 0, 3), SIMD.float32x4.swizzle(tmp, 2, 0, 1, 3)));\n            s = SIMD.float32x4.mul(s, SIMD.float32x4.reciprocalSqrtApproximation(tmp));\n            var zero = SIMD.float32x4.splat(0.0);\n            s = SIMD.float32x4.neg(s);\n            var tmp01 = SIMD.float32x4.shuffle(s, u, 0, 1, 4, 5);\n            var tmp23 = SIMD.float32x4.shuffle(f, zero, 0, 1, 4, 5);\n            var a0 = SIMD.float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);\n            var a1 = SIMD.float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);\n            tmp01 = SIMD.float32x4.shuffle(s, u, 2, 3, 6, 7);\n            tmp23 = SIMD.float32x4.shuffle(f, zero, 2, 3, 6, 7);\n            var a2 = SIMD.float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);\n            var a3 = SIMD.float32x4(0.0, 0.0, 0.0, 1.0);\n            var b0 = SIMD.float32x4(1.0, 0.0, 0.0, 0.0);\n            var b1 = SIMD.float32x4(0.0, 1.0, 0.0, 0.0);\n            var b2 = SIMD.float32x4(0.0, 0.0, 1.0, 0.0);\n            var b3 = SIMD.float32x4.neg(eye);\n            b3 = SIMD.float32x4.withW(b3, 1.0);\n            SIMD.float32x4.store(out, 0, SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(b0, 0, 0, 0, 0), a0), SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(b0, 1, 1, 1, 1), a1), SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(b0, 2, 2, 2, 2), a2), SIMD.float32x4.mul(SIMD.float32x4.swizzle(b0, 3, 3, 3, 3), a3)))));\n            SIMD.float32x4.store(out, 4, SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(b1, 0, 0, 0, 0), a0), SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(b1, 1, 1, 1, 1), a1), SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(b1, 2, 2, 2, 2), a2), SIMD.float32x4.mul(SIMD.float32x4.swizzle(b1, 3, 3, 3, 3), a3)))));\n            SIMD.float32x4.store(out, 8, SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(b2, 0, 0, 0, 0), a0), SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(b2, 1, 1, 1, 1), a1), SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(b2, 2, 2, 2, 2), a2), SIMD.float32x4.mul(SIMD.float32x4.swizzle(b2, 3, 3, 3, 3), a3)))));\n            SIMD.float32x4.store(out, 12, SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(b3, 0, 0, 0, 0), a0), SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(b3, 1, 1, 1, 1), a1), SIMD.float32x4.add(SIMD.float32x4.mul(SIMD.float32x4.swizzle(b3, 2, 2, 2, 2), a2), SIMD.float32x4.mul(SIMD.float32x4.swizzle(b3, 3, 3, 3, 3), a3)))));\n        };\n        Matrix.OrthoLH = function (width, height, znear, zfar) {\n            var matrix = Matrix.Zero();\n            Matrix.OrthoLHToRef(width, height, znear, zfar, matrix);\n            return matrix;\n        };\n        Matrix.OrthoLHToRef = function (width, height, znear, zfar, result) {\n            var hw = 2.0 \/ width;\n            var hh = 2.0 \/ height;\n            var id = 1.0 \/ (zfar - znear);\n            var nid = znear \/ (znear - zfar);\n            Matrix.FromValuesToRef(hw, 0, 0, 0, 0, hh, 0, 0, 0, 0, id, 0, 0, 0, nid, 1, result);\n        };\n        Matrix.OrthoOffCenterLH = function (left, right, bottom, top, znear, zfar) {\n            var matrix = Matrix.Zero();\n            Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, matrix);\n            return matrix;\n        };\n        Matrix.OrthoOffCenterLHToRef = function (left, right, bottom, top, znear, zfar, result) {\n            result.m[0] = 2.0 \/ (right - left);\n            result.m[1] = result.m[2] = result.m[3] = 0;\n            result.m[5] = 2.0 \/ (top - bottom);\n            result.m[4] = result.m[6] = result.m[7] = 0;\n            result.m[10] = -1.0 \/ (znear - zfar);\n            result.m[8] = result.m[9] = result.m[11] = 0;\n            result.m[12] = (left + right) \/ (left - right);\n            result.m[13] = (top + bottom) \/ (bottom - top);\n            result.m[14] = znear \/ (znear - zfar);\n            result.m[15] = 1.0;\n        };\n        Matrix.PerspectiveLH = function (width, height, znear, zfar) {\n            var matrix = Matrix.Zero();\n            matrix.m[0] = (2.0 * znear) \/ width;\n            matrix.m[1] = matrix.m[2] = matrix.m[3] = 0.0;\n            matrix.m[5] = (2.0 * znear) \/ height;\n            matrix.m[4] = matrix.m[6] = matrix.m[7] = 0.0;\n            matrix.m[10] = -zfar \/ (znear - zfar);\n            matrix.m[8] = matrix.m[9] = 0.0;\n            matrix.m[11] = 1.0;\n            matrix.m[12] = matrix.m[13] = matrix.m[15] = 0.0;\n            matrix.m[14] = (znear * zfar) \/ (znear - zfar);\n            return matrix;\n        };\n        Matrix.PerspectiveFovLH = function (fov, aspect, znear, zfar) {\n            var matrix = Matrix.Zero();\n            Matrix.PerspectiveFovLHToRef(fov, aspect, znear, zfar, matrix);\n            return matrix;\n        };\n        Matrix.PerspectiveFovLHToRef = function (fov, aspect, znear, zfar, result, fovMode) {\n            if (fovMode === void 0) { fovMode = BABYLON.Camera.FOVMODE_VERTICAL_FIXED; }\n            var tan = 1.0 \/ (Math.tan(fov * 0.5));\n            var v_fixed = (fovMode === BABYLON.Camera.FOVMODE_VERTICAL_FIXED);\n            if (v_fixed) {\n                result.m[0] = tan \/ aspect;\n            }\n            else {\n                result.m[0] = tan;\n            }\n            result.m[1] = result.m[2] = result.m[3] = 0.0;\n            if (v_fixed) {\n                result.m[5] = tan;\n            }\n            else {\n                result.m[5] = tan * aspect;\n            }\n            result.m[4] = result.m[6] = result.m[7] = 0.0;\n            result.m[8] = result.m[9] = 0.0;\n            result.m[10] = -zfar \/ (znear - zfar);\n            result.m[11] = 1.0;\n            result.m[12] = result.m[13] = result.m[15] = 0.0;\n            result.m[14] = (znear * zfar) \/ (znear - zfar);\n        };\n        Matrix.GetFinalMatrix = function (viewport, world, view, projection, zmin, zmax) {\n            var cw = viewport.width;\n            var ch = viewport.height;\n            var cx = viewport.x;\n            var cy = viewport.y;\n            var viewportMatrix = Matrix.FromValues(cw \/ 2.0, 0, 0, 0, 0, -ch \/ 2.0, 0, 0, 0, 0, zmax - zmin, 0, cx + cw \/ 2.0, ch \/ 2.0 + cy, zmin, 1);\n            return world.multiply(view).multiply(projection).multiply(viewportMatrix);\n        };\n        Matrix.Transpose = function (matrix) {\n            var result = new Matrix();\n            result.m[0] = matrix.m[0];\n            result.m[1] = matrix.m[4];\n            result.m[2] = matrix.m[8];\n            result.m[3] = matrix.m[12];\n            result.m[4] = matrix.m[1];\n            result.m[5] = matrix.m[5];\n            result.m[6] = matrix.m[9];\n            result.m[7] = matrix.m[13];\n            result.m[8] = matrix.m[2];\n            result.m[9] = matrix.m[6];\n            result.m[10] = matrix.m[10];\n            result.m[11] = matrix.m[14];\n            result.m[12] = matrix.m[3];\n            result.m[13] = matrix.m[7];\n            result.m[14] = matrix.m[11];\n            result.m[15] = matrix.m[15];\n            return result;\n        };\n        Matrix.Reflection = function (plane) {\n            var matrix = new Matrix();\n            Matrix.ReflectionToRef(plane, matrix);\n            return matrix;\n        };\n        Matrix.ReflectionToRef = function (plane, result) {\n            plane.normalize();\n            var x = plane.normal.x;\n            var y = plane.normal.y;\n            var z = plane.normal.z;\n            var temp = -2 * x;\n            var temp2 = -2 * y;\n            var temp3 = -2 * z;\n            result.m[0] = (temp * x) + 1;\n            result.m[1] = temp2 * x;\n            result.m[2] = temp3 * x;\n            result.m[3] = 0.0;\n            result.m[4] = temp * y;\n            result.m[5] = (temp2 * y) + 1;\n            result.m[6] = temp3 * y;\n            result.m[7] = 0.0;\n            result.m[8] = temp * z;\n            result.m[9] = temp2 * z;\n            result.m[10] = (temp3 * z) + 1;\n            result.m[11] = 0.0;\n            result.m[12] = temp * plane.d;\n            result.m[13] = temp2 * plane.d;\n            result.m[14] = temp3 * plane.d;\n            result.m[15] = 1.0;\n        };\n        Matrix._tempQuaternion = new Quaternion();\n        Matrix._xAxis = Vector3.Zero();\n        Matrix._yAxis = Vector3.Zero();\n        Matrix._zAxis = Vector3.Zero();\n        return Matrix;\n    })();\n    BABYLON.Matrix = Matrix;\n    var Plane = (function () {\n        function Plane(a, b, c, d) {\n            this.normal = new Vector3(a, b, c);\n            this.d = d;\n        }\n        Plane.prototype.asArray = function () {\n            return [this.normal.x, this.normal.y, this.normal.z, this.d];\n        };\n        \/\/ Methods\n        Plane.prototype.clone = function () {\n            return new Plane(this.normal.x, this.normal.y, this.normal.z, this.d);\n        };\n        Plane.prototype.normalize = function () {\n            var norm = (Math.sqrt((this.normal.x * this.normal.x) + (this.normal.y * this.normal.y) + (this.normal.z * this.normal.z)));\n            var magnitude = 0;\n            if (norm !== 0) {\n                magnitude = 1.0 \/ norm;\n            }\n            this.normal.x *= magnitude;\n            this.normal.y *= magnitude;\n            this.normal.z *= magnitude;\n            this.d *= magnitude;\n            return this;\n        };\n        Plane.prototype.transform = function (transformation) {\n            var transposedMatrix = Matrix.Transpose(transformation);\n            var x = this.normal.x;\n            var y = this.normal.y;\n            var z = this.normal.z;\n            var d = this.d;\n            var normalX = (((x * transposedMatrix.m[0]) + (y * transposedMatrix.m[1])) + (z * transposedMatrix.m[2])) + (d * transposedMatrix.m[3]);\n            var normalY = (((x * transposedMatrix.m[4]) + (y * transposedMatrix.m[5])) + (z * transposedMatrix.m[6])) + (d * transposedMatrix.m[7]);\n            var normalZ = (((x * transposedMatrix.m[8]) + (y * transposedMatrix.m[9])) + (z * transposedMatrix.m[10])) + (d * transposedMatrix.m[11]);\n            var finalD = (((x * transposedMatrix.m[12]) + (y * transposedMatrix.m[13])) + (z * transposedMatrix.m[14])) + (d * transposedMatrix.m[15]);\n            return new Plane(normalX, normalY, normalZ, finalD);\n        };\n        Plane.prototype.dotCoordinate = function (point) {\n            return ((((this.normal.x * point.x) + (this.normal.y * point.y)) + (this.normal.z * point.z)) + this.d);\n        };\n        Plane.prototype.copyFromPoints = function (point1, point2, point3) {\n            var x1 = point2.x - point1.x;\n            var y1 = point2.y - point1.y;\n            var z1 = point2.z - point1.z;\n            var x2 = point3.x - point1.x;\n            var y2 = point3.y - point1.y;\n            var z2 = point3.z - point1.z;\n            var yz = (y1 * z2) - (z1 * y2);\n            var xz = (z1 * x2) - (x1 * z2);\n            var xy = (x1 * y2) - (y1 * x2);\n            var pyth = (Math.sqrt((yz * yz) + (xz * xz) + (xy * xy)));\n            var invPyth;\n            if (pyth !== 0) {\n                invPyth = 1.0 \/ pyth;\n            }\n            else {\n                invPyth = 0;\n            }\n            this.normal.x = yz * invPyth;\n            this.normal.y = xz * invPyth;\n            this.normal.z = xy * invPyth;\n            this.d = -((this.normal.x * point1.x) + (this.normal.y * point1.y) + (this.normal.z * point1.z));\n            return this;\n        };\n        Plane.prototype.isFrontFacingTo = function (direction, epsilon) {\n            var dot = Vector3.Dot(this.normal, direction);\n            return (dot <= epsilon);\n        };\n        Plane.prototype.signedDistanceTo = function (point) {\n            return Vector3.Dot(point, this.normal) + this.d;\n        };\n        \/\/ Statics\n        Plane.FromArray = function (array) {\n            return new Plane(array[0], array[1], array[2], array[3]);\n        };\n        Plane.FromPoints = function (point1, point2, point3) {\n            var result = new Plane(0, 0, 0, 0);\n            result.copyFromPoints(point1, point2, point3);\n            return result;\n        };\n        Plane.FromPositionAndNormal = function (origin, normal) {\n            var result = new Plane(0, 0, 0, 0);\n            normal.normalize();\n            result.normal = normal;\n            result.d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\n            return result;\n        };\n        Plane.SignedDistanceToPlaneFromPositionAndNormal = function (origin, normal, point) {\n            var d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\n            return Vector3.Dot(point, normal) + d;\n        };\n        return Plane;\n    })();\n    BABYLON.Plane = Plane;\n    var Viewport = (function () {\n        function Viewport(x, y, width, height) {\n            this.x = x;\n            this.y = y;\n            this.width = width;\n            this.height = height;\n        }\n        Viewport.prototype.toGlobal = function (engine) {\n            var width = engine.getRenderWidth();\n            var height = engine.getRenderHeight();\n            return new Viewport(this.x * width, this.y * height, this.width * width, this.height * height);\n        };\n        return Viewport;\n    })();\n    BABYLON.Viewport = Viewport;\n    var Frustum = (function () {\n        function Frustum() {\n        }\n        Frustum.GetPlanes = function (transform) {\n            var frustumPlanes = [];\n            for (var index = 0; index < 6; index++) {\n                frustumPlanes.push(new Plane(0, 0, 0, 0));\n            }\n            Frustum.GetPlanesToRef(transform, frustumPlanes);\n            return frustumPlanes;\n        };\n        Frustum.GetPlanesToRef = function (transform, frustumPlanes) {\n            \/\/ Near\n            frustumPlanes[0].normal.x = transform.m[3] + transform.m[2];\n            frustumPlanes[0].normal.y = transform.m[7] + transform.m[6];\n            frustumPlanes[0].normal.z = transform.m[10] + transform.m[10];\n            frustumPlanes[0].d = transform.m[15] + transform.m[14];\n            frustumPlanes[0].normalize();\n            \/\/ Far\n            frustumPlanes[1].normal.x = transform.m[3] - transform.m[2];\n            frustumPlanes[1].normal.y = transform.m[7] - transform.m[6];\n            frustumPlanes[1].normal.z = transform.m[11] - transform.m[10];\n            frustumPlanes[1].d = transform.m[15] - transform.m[14];\n            frustumPlanes[1].normalize();\n            \/\/ Left\n            frustumPlanes[2].normal.x = transform.m[3] + transform.m[0];\n            frustumPlanes[2].normal.y = transform.m[7] + transform.m[4];\n            frustumPlanes[2].normal.z = transform.m[11] + transform.m[8];\n            frustumPlanes[2].d = transform.m[15] + transform.m[12];\n            frustumPlanes[2].normalize();\n            \/\/ Right\n            frustumPlanes[3].normal.x = transform.m[3] - transform.m[0];\n            frustumPlanes[3].normal.y = transform.m[7] - transform.m[4];\n            frustumPlanes[3].normal.z = transform.m[11] - transform.m[8];\n            frustumPlanes[3].d = transform.m[15] - transform.m[12];\n            frustumPlanes[3].normalize();\n            \/\/ Top\n            frustumPlanes[4].normal.x = transform.m[3] - transform.m[1];\n            frustumPlanes[4].normal.y = transform.m[7] - transform.m[5];\n            frustumPlanes[4].normal.z = transform.m[11] - transform.m[9];\n            frustumPlanes[4].d = transform.m[15] - transform.m[13];\n            frustumPlanes[4].normalize();\n            \/\/ Bottom\n            frustumPlanes[5].normal.x = transform.m[3] + transform.m[1];\n            frustumPlanes[5].normal.y = transform.m[7] + transform.m[5];\n            frustumPlanes[5].normal.z = transform.m[11] + transform.m[9];\n            frustumPlanes[5].d = transform.m[15] + transform.m[13];\n            frustumPlanes[5].normalize();\n        };\n        return Frustum;\n    })();\n    BABYLON.Frustum = Frustum;\n    var Ray = (function () {\n        function Ray(origin, direction, length) {\n            if (length === void 0) { length = Number.MAX_VALUE; }\n            this.origin = origin;\n            this.direction = direction;\n            this.length = length;\n        }\n        \/\/ Methods\n        Ray.prototype.intersectsBoxMinMax = function (minimum, maximum) {\n            var d = 0.0;\n            var maxValue = Number.MAX_VALUE;\n            if (Math.abs(this.direction.x) < 0.0000001) {\n                if (this.origin.x < minimum.x || this.origin.x > maximum.x) {\n                    return false;\n                }\n            }\n            else {\n                var inv = 1.0 \/ this.direction.x;\n                var min = (minimum.x - this.origin.x) * inv;\n                var max = (maximum.x - this.origin.x) * inv;\n                if (max === -Infinity) {\n                    max = Infinity;\n                }\n                if (min > max) {\n                    var temp = min;\n                    min = max;\n                    max = temp;\n                }\n                d = Math.max(min, d);\n                maxValue = Math.min(max, maxValue);\n                if (d > maxValue) {\n                    return false;\n                }\n            }\n            if (Math.abs(this.direction.y) < 0.0000001) {\n                if (this.origin.y < minimum.y || this.origin.y > maximum.y) {\n                    return false;\n                }\n            }\n            else {\n                inv = 1.0 \/ this.direction.y;\n                min = (minimum.y - this.origin.y) * inv;\n                max = (maximum.y - this.origin.y) * inv;\n                if (max === -Infinity) {\n                    max = Infinity;\n                }\n                if (min > max) {\n                    temp = min;\n                    min = max;\n                    max = temp;\n                }\n                d = Math.max(min, d);\n                maxValue = Math.min(max, maxValue);\n                if (d > maxValue) {\n                    return false;\n                }\n            }\n            if (Math.abs(this.direction.z) < 0.0000001) {\n                if (this.origin.z < minimum.z || this.origin.z > maximum.z) {\n                    return false;\n                }\n            }\n            else {\n                inv = 1.0 \/ this.direction.z;\n                min = (minimum.z - this.origin.z) * inv;\n                max = (maximum.z - this.origin.z) * inv;\n                if (max === -Infinity) {\n                    max = Infinity;\n                }\n                if (min > max) {\n                    temp = min;\n                    min = max;\n                    max = temp;\n                }\n                d = Math.max(min, d);\n                maxValue = Math.min(max, maxValue);\n                if (d > maxValue) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        Ray.prototype.intersectsBox = function (box) {\n            return this.intersectsBoxMinMax(box.minimum, box.maximum);\n        };\n        Ray.prototype.intersectsSphere = function (sphere) {\n            var x = sphere.center.x - this.origin.x;\n            var y = sphere.center.y - this.origin.y;\n            var z = sphere.center.z - this.origin.z;\n            var pyth = (x * x) + (y * y) + (z * z);\n            var rr = sphere.radius * sphere.radius;\n            if (pyth <= rr) {\n                return true;\n            }\n            var dot = (x * this.direction.x) + (y * this.direction.y) + (z * this.direction.z);\n            if (dot < 0.0) {\n                return false;\n            }\n            var temp = pyth - (dot * dot);\n            return temp <= rr;\n        };\n        Ray.prototype.intersectsTriangle = function (vertex0, vertex1, vertex2) {\n            if (!this._edge1) {\n                this._edge1 = Vector3.Zero();\n                this._edge2 = Vector3.Zero();\n                this._pvec = Vector3.Zero();\n                this._tvec = Vector3.Zero();\n                this._qvec = Vector3.Zero();\n            }\n            vertex1.subtractToRef(vertex0, this._edge1);\n            vertex2.subtractToRef(vertex0, this._edge2);\n            Vector3.CrossToRef(this.direction, this._edge2, this._pvec);\n            var det = Vector3.Dot(this._edge1, this._pvec);\n            if (det === 0) {\n                return null;\n            }\n            var invdet = 1 \/ det;\n            this.origin.subtractToRef(vertex0, this._tvec);\n            var bu = Vector3.Dot(this._tvec, this._pvec) * invdet;\n            if (bu < 0 || bu > 1.0) {\n                return null;\n            }\n            Vector3.CrossToRef(this._tvec, this._edge1, this._qvec);\n            var bv = Vector3.Dot(this.direction, this._qvec) * invdet;\n            if (bv < 0 || bu + bv > 1.0) {\n                return null;\n            }\n            \/\/check if the distance is longer than the predefined length.\n            var distance = Vector3.Dot(this._edge2, this._qvec) * invdet;\n            if (distance > this.length) {\n                return null;\n            }\n            return new BABYLON.IntersectionInfo(bu, bv, distance);\n        };\n        \/\/ Statics\n        Ray.CreateNew = function (x, y, viewportWidth, viewportHeight, world, view, projection) {\n            var start = Vector3.Unproject(new Vector3(x, y, 0), viewportWidth, viewportHeight, world, view, projection);\n            var end = Vector3.Unproject(new Vector3(x, y, 1), viewportWidth, viewportHeight, world, view, projection);\n            var direction = end.subtract(start);\n            direction.normalize();\n            return new Ray(start, direction);\n        };\n        \/**\n        * Function will create a new transformed ray starting from origin and ending at the end point. Ray\'s length will be set, and ray will be\n        * transformed to the given world matrix.\n        * @param origin The origin point\n        * @param end The end point\n        * @param world a matrix to transform the ray to. Default is the identity matrix.\n        *\/\n        Ray.CreateNewFromTo = function (origin, end, world) {\n            if (world === void 0) { world = Matrix.Identity(); }\n            var direction = end.subtract(origin);\n            var length = Math.sqrt((direction.x * direction.x) + (direction.y * direction.y) + (direction.z * direction.z));\n            direction.normalize();\n            return Ray.Transform(new Ray(origin, direction, length), world);\n        };\n        Ray.Transform = function (ray, matrix) {\n            var newOrigin = Vector3.TransformCoordinates(ray.origin, matrix);\n            var newDirection = Vector3.TransformNormal(ray.direction, matrix);\n            return new Ray(newOrigin, newDirection, ray.length);\n        };\n        return Ray;\n    })();\n    BABYLON.Ray = Ray;\n    (function (Space) {\n        Space[Space[\"LOCAL\"] = 0] = \"LOCAL\";\n        Space[Space[\"WORLD\"] = 1] = \"WORLD\";\n    })(BABYLON.Space || (BABYLON.Space = {}));\n    var Space = BABYLON.Space;\n    var Axis = (function () {\n        function Axis() {\n        }\n        Axis.X = new Vector3(1, 0, 0);\n        Axis.Y = new Vector3(0, 1, 0);\n        Axis.Z = new Vector3(0, 0, 1);\n        return Axis;\n    })();\n    BABYLON.Axis = Axis;\n    ;\n    var BezierCurve = (function () {\n        function BezierCurve() {\n        }\n        BezierCurve.interpolate = function (t, x1, y1, x2, y2) {\n            \/\/ Extract X (which is equal to time here)\n            var f0 = 1 - 3 * x2 + 3 * x1;\n            var f1 = 3 * x2 - 6 * x1;\n            var f2 = 3 * x1;\n            var refinedT = t;\n            for (var i = 0; i < 5; i++) {\n                var refinedT2 = refinedT * refinedT;\n                var refinedT3 = refinedT2 * refinedT;\n                var x = f0 * refinedT3 + f1 * refinedT2 + f2 * refinedT;\n                var slope = 1.0 \/ (3.0 * f0 * refinedT2 + 2.0 * f1 * refinedT + f2);\n                refinedT -= (x - t) * slope;\n                refinedT = Math.min(1, Math.max(0, refinedT));\n            }\n            \/\/ Resolve cubic bezier for the given x\n            return 3 * Math.pow(1 - refinedT, 2) * refinedT * y1 + 3 * (1 - refinedT) * Math.pow(refinedT, 2) * y2 + Math.pow(refinedT, 3);\n        };\n        return BezierCurve;\n    })();\n    BABYLON.BezierCurve = BezierCurve;\n    (function (Orientation) {\n        Orientation[Orientation[\"CW\"] = 0] = \"CW\";\n        Orientation[Orientation[\"CCW\"] = 1] = \"CCW\";\n    })(BABYLON.Orientation || (BABYLON.Orientation = {}));\n    var Orientation = BABYLON.Orientation;\n    var Angle = (function () {\n        function Angle(radians) {\n            var _this = this;\n            this.degrees = function () { return _this._radians * 180 \/ Math.PI; };\n            this.radians = function () { return _this._radians; };\n            this._radians = radians;\n            if (this._radians < 0)\n                this._radians += (2 * Math.PI);\n        }\n        Angle.BetweenTwoPoints = function (a, b) {\n            var delta = b.subtract(a);\n            var theta = Math.atan2(delta.y, delta.x);\n            return new Angle(theta);\n        };\n        Angle.FromRadians = function (radians) {\n            return new Angle(radians);\n        };\n        Angle.FromDegrees = function (degrees) {\n            return new Angle(degrees * Math.PI \/ 180);\n        };\n        return Angle;\n    })();\n    BABYLON.Angle = Angle;\n    var Arc2 = (function () {\n        function Arc2(startPoint, midPoint, endPoint) {\n            this.startPoint = startPoint;\n            this.midPoint = midPoint;\n            this.endPoint = endPoint;\n            var temp = Math.pow(midPoint.x, 2) + Math.pow(midPoint.y, 2);\n            var startToMid = (Math.pow(startPoint.x, 2) + Math.pow(startPoint.y, 2) - temp) \/ 2.;\n            var midToEnd = (temp - Math.pow(endPoint.x, 2) - Math.pow(endPoint.y, 2)) \/ 2.;\n            var det = (startPoint.x - midPoint.x) * (midPoint.y - endPoint.y) - (midPoint.x - endPoint.x) * (startPoint.y - midPoint.y);\n            this.centerPoint = new Vector2((startToMid * (midPoint.y - endPoint.y) - midToEnd * (startPoint.y - midPoint.y)) \/ det, ((startPoint.x - midPoint.x) * midToEnd - (midPoint.x - endPoint.x) * startToMid) \/ det);\n            this.radius = this.centerPoint.subtract(this.startPoint).length();\n            this.startAngle = Angle.BetweenTwoPoints(this.centerPoint, this.startPoint);\n            var a1 = this.startAngle.degrees();\n            var a2 = Angle.BetweenTwoPoints(this.centerPoint, this.midPoint).degrees();\n            var a3 = Angle.BetweenTwoPoints(this.centerPoint, this.endPoint).degrees();\n            \/\/ angles correction\n            if (a2 - a1 > +180.0)\n                a2 -= 360.0;\n            if (a2 - a1 < -180.0)\n                a2 += 360.0;\n            if (a3 - a2 > +180.0)\n                a3 -= 360.0;\n            if (a3 - a2 < -180.0)\n                a3 += 360.0;\n            this.orientation = (a2 - a1) < 0 ? 0 \/* CW *\/ : 1 \/* CCW *\/;\n            this.angle = Angle.FromDegrees(this.orientation === 0 \/* CW *\/ ? a1 - a3 : a3 - a1);\n        }\n        return Arc2;\n    })();\n    BABYLON.Arc2 = Arc2;\n    var PathCursor = (function () {\n        function PathCursor(path) {\n            this.path = path;\n            this._onchange = new Array();\n            this.value = 0;\n            this.animations = new Array();\n        }\n        PathCursor.prototype.getPoint = function () {\n            var point = this.path.getPointAtLengthPosition(this.value);\n            return new Vector3(point.x, 0, point.y);\n        };\n        PathCursor.prototype.moveAhead = function (step) {\n            if (step === void 0) { step = 0.002; }\n            this.move(step);\n            return this;\n        };\n        PathCursor.prototype.moveBack = function (step) {\n            if (step === void 0) { step = 0.002; }\n            this.move(-step);\n            return this;\n        };\n        PathCursor.prototype.move = function (step) {\n            if (Math.abs(step) > 1) {\n                throw \"step size should be less than 1.\";\n            }\n            this.value += step;\n            this.ensureLimits();\n            this.raiseOnChange();\n            return this;\n        };\n        PathCursor.prototype.ensureLimits = function () {\n            while (this.value > 1) {\n                this.value -= 1;\n            }\n            while (this.value < 0) {\n                this.value += 1;\n            }\n            return this;\n        };\n        \/\/ used by animation engine\n        PathCursor.prototype.markAsDirty = function (propertyName) {\n            this.ensureLimits();\n            this.raiseOnChange();\n            return this;\n        };\n        PathCursor.prototype.raiseOnChange = function () {\n            var _this = this;\n            this._onchange.forEach(function (f) { return f(_this); });\n            return this;\n        };\n        PathCursor.prototype.onchange = function (f) {\n            this._onchange.push(f);\n            return this;\n        };\n        return PathCursor;\n    })();\n    BABYLON.PathCursor = PathCursor;\n    var Path2 = (function () {\n        function Path2(x, y) {\n            this._points = new Array();\n            this._length = 0;\n            this.closed = false;\n            this._points.push(new Vector2(x, y));\n        }\n        Path2.prototype.addLineTo = function (x, y) {\n            if (closed) {\n                BABYLON.Tools.Error(\"cannot add lines to closed paths\");\n                return this;\n            }\n            var newPoint = new Vector2(x, y);\n            var previousPoint = this._points[this._points.length - 1];\n            this._points.push(newPoint);\n            this._length += newPoint.subtract(previousPoint).length();\n            return this;\n        };\n        Path2.prototype.addArcTo = function (midX, midY, endX, endY, numberOfSegments) {\n            if (numberOfSegments === void 0) { numberOfSegments = 36; }\n            if (closed) {\n                BABYLON.Tools.Error(\"cannot add arcs to closed paths\");\n                return this;\n            }\n            var startPoint = this._points[this._points.length - 1];\n            var midPoint = new Vector2(midX, midY);\n            var endPoint = new Vector2(endX, endY);\n            var arc = new Arc2(startPoint, midPoint, endPoint);\n            var increment = arc.angle.radians() \/ numberOfSegments;\n            if (arc.orientation === 0 \/* CW *\/)\n                increment *= -1;\n            var currentAngle = arc.startAngle.radians() + increment;\n            for (var i = 0; i < numberOfSegments; i++) {\n                var x = Math.cos(currentAngle) * arc.radius + arc.centerPoint.x;\n                var y = Math.sin(currentAngle) * arc.radius + arc.centerPoint.y;\n                this.addLineTo(x, y);\n                currentAngle += increment;\n            }\n            return this;\n        };\n        Path2.prototype.close = function () {\n            this.closed = true;\n            return this;\n        };\n        Path2.prototype.length = function () {\n            var result = this._length;\n            if (!this.closed) {\n                var lastPoint = this._points[this._points.length - 1];\n                var firstPoint = this._points[0];\n                result += (firstPoint.subtract(lastPoint).length());\n            }\n            return result;\n        };\n        Path2.prototype.getPoints = function () {\n            return this._points;\n        };\n        Path2.prototype.getPointAtLengthPosition = function (normalizedLengthPosition) {\n            if (normalizedLengthPosition < 0 || normalizedLengthPosition > 1) {\n                BABYLON.Tools.Error(\"normalized length position should be between 0 and 1.\");\n                return Vector2.Zero();\n            }\n            var lengthPosition = normalizedLengthPosition * this.length();\n            var previousOffset = 0;\n            for (var i = 0; i < this._points.length; i++) {\n                var j = (i + 1) % this._points.length;\n                var a = this._points[i];\n                var b = this._points[j];\n                var bToA = b.subtract(a);\n                var nextOffset = (bToA.length() + previousOffset);\n                if (lengthPosition >= previousOffset && lengthPosition <= nextOffset) {\n                    var dir = bToA.normalize();\n                    var localOffset = lengthPosition - previousOffset;\n                    return new Vector2(a.x + (dir.x * localOffset), a.y + (dir.y * localOffset));\n                }\n                previousOffset = nextOffset;\n            }\n            BABYLON.Tools.Error(\"internal error\");\n            return Vector2.Zero();\n        };\n        Path2.StartingAt = function (x, y) {\n            return new Path2(x, y);\n        };\n        return Path2;\n    })();\n    BABYLON.Path2 = Path2;\n    var Path3D = (function () {\n        function Path3D(path) {\n            this.path = path;\n            this._curve = new Array();\n            this._distances = new Array();\n            this._tangents = new Array();\n            this._normals = new Array();\n            this._binormals = new Array();\n            this._curve = path.slice(); \/\/ copy array  \n            this._compute();\n        }\n        Path3D.prototype.getCurve = function () {\n            return this._curve;\n        };\n        Path3D.prototype.getTangents = function () {\n            return this._tangents;\n        };\n        Path3D.prototype.getNormals = function () {\n            return this._normals;\n        };\n        Path3D.prototype.getBinormals = function () {\n            return this._binormals;\n        };\n        Path3D.prototype.getDistances = function () {\n            return this._distances;\n        };\n        Path3D.prototype.update = function (path) {\n            for (var i = 0; i < path.length; i++) {\n                this._curve[i] = path[i];\n            }\n            this._compute();\n            return this;\n        };\n        \/\/ private function compute() : computes tangents, normals and binormals\n        Path3D.prototype._compute = function () {\n            var l = this._curve.length;\n            \/\/ first and last tangents\n            this._tangents[0] = this._curve[1].subtract(this._curve[0]);\n            this._tangents[0].normalize();\n            this._tangents[l - 1] = this._curve[l - 1].subtract(this._curve[l - 2]);\n            this._tangents[l - 1].normalize();\n            \/\/ normals and binormals at first point : arbitrary vector with _normalVector()\n            var tg0 = this._tangents[0];\n            var pp0 = this._normalVector(this._curve[0], tg0);\n            this._normals[0] = pp0;\n            this._normals[0].normalize();\n            this._binormals[0] = Vector3.Cross(tg0, this._normals[0]);\n            this._normals[0].normalize();\n            this._distances[0] = 0;\n            \/\/ normals and binormals : next points\n            var prev; \/\/ previous vector (segment)\n            var cur; \/\/ current vector (segment)\n            var curTang; \/\/ current tangent\n            var prevNorm; \/\/ previous normal\n            var prevBinor; \/\/ previous binormal\n            for (var i = 1; i < l; i++) {\n                \/\/ tangents\n                prev = this._curve[i].subtract(this._curve[i - 1]);\n                if (i < l - 1) {\n                    cur = this._curve[i + 1].subtract(this._curve[i]);\n                    this._tangents[i] = prev.add(cur);\n                    this._tangents[i].normalize();\n                }\n                this._distances[i] = this._distances[i - 1] + prev.length();\n                \/\/ normals and binormals\n                \/\/ http:\/\/www.cs.cmu.edu\/afs\/andrew\/scs\/cs\/15-462\/web\/old\/asst2camera.html\n                curTang = this._tangents[i];\n                prevNorm = this._normals[i - 1];\n                prevBinor = this._binormals[i - 1];\n                this._normals[i] = Vector3.Cross(prevBinor, curTang);\n                this._normals[i].normalize();\n                this._binormals[i] = Vector3.Cross(curTang, this._normals[i]);\n                this._binormals[i].normalize();\n            }\n        };\n        \/\/ private function normalVector(v0, vt) :\n        \/\/ returns an arbitrary point in the plane defined by the point v0 and the vector vt orthogonal to this plane\n        Path3D.prototype._normalVector = function (v0, vt) {\n            var point;\n            if (vt.x !== 1) {\n                point = new Vector3(1, 0, 0);\n            }\n            else if (vt.y !== 1) {\n                point = new Vector3(0, 1, 0);\n            }\n            else if (vt.z !== 1) {\n                point = new Vector3(0, 0, 1);\n            }\n            var normal0 = Vector3.Cross(vt, point);\n            normal0.normalize();\n            return normal0;\n        };\n        return Path3D;\n    })();\n    BABYLON.Path3D = Path3D;\n    var Curve3 = (function () {\n        function Curve3(points) {\n            this._points = points;\n        }\n        \/\/ QuadraticBezier(origin_V3, control_V3, destination_V3 )\n        Curve3.CreateQuadraticBezier = function (v0, v1, v2, nbPoints) {\n            nbPoints = nbPoints > 2 ? nbPoints : 3;\n            var bez = new Array();\n            var equation = function (t, val0, val1, val2) {\n                var res = (1 - t) * (1 - t) * val0 + 2 * t * (1 - t) * val1 + t * t * val2;\n                return res;\n            };\n            for (var i = 0; i <= nbPoints; i++) {\n                bez.push(new Vector3(equation(i \/ nbPoints, v0.x, v1.x, v2.x), equation(i \/ nbPoints, v0.y, v1.y, v2.y), equation(i \/ nbPoints, v0.z, v1.z, v2.z)));\n            }\n            return new Curve3(bez);\n        };\n        \/\/ CubicBezier(origin_V3, control1_V3, control2_V3, destination_V3)\n        Curve3.CreateCubicBezier = function (v0, v1, v2, v3, nbPoints) {\n            nbPoints = nbPoints > 3 ? nbPoints : 4;\n            var bez = new Array();\n            var equation = function (t, val0, val1, val2, val3) {\n                var res = (1 - t) * (1 - t) * (1 - t) * val0 + 3 * t * (1 - t) * (1 - t) * val1 + 3 * t * t * (1 - t) * val2 + t * t * t * val3;\n                return res;\n            };\n            for (var i = 0; i <= nbPoints; i++) {\n                bez.push(new Vector3(equation(i \/ nbPoints, v0.x, v1.x, v2.x, v3.x), equation(i \/ nbPoints, v0.y, v1.y, v2.y, v3.y), equation(i \/ nbPoints, v0.z, v1.z, v2.z, v3.z)));\n            }\n            return new Curve3(bez);\n        };\n        Curve3.prototype.getPoints = function () {\n            return this._points;\n        };\n        Curve3.prototype.continue = function (curve) {\n            var lastPoint = this._points[this._points.length - 1];\n            var continuedPoints = this._points.slice();\n            var curvePoints = curve.getPoints();\n            for (var i = 1; i < curvePoints.length; i++) {\n                continuedPoints.push(curvePoints[i].subtract(curvePoints[0]).add(lastPoint));\n            }\n            return new Curve3(continuedPoints);\n        };\n        return Curve3;\n    })();\n    BABYLON.Curve3 = Curve3;\n    \/\/ Vertex formats\n    var PositionNormalVertex = (function () {\n        function PositionNormalVertex(position, normal) {\n            if (position === void 0) { position = Vector3.Zero(); }\n            if (normal === void 0) { normal = Vector3.Up(); }\n            this.position = position;\n            this.normal = normal;\n        }\n        PositionNormalVertex.prototype.clone = function () {\n            return new PositionNormalVertex(this.position.clone(), this.normal.clone());\n        };\n        return PositionNormalVertex;\n    })();\n    BABYLON.PositionNormalVertex = PositionNormalVertex;\n    var PositionNormalTextureVertex = (function () {\n        function PositionNormalTextureVertex(position, normal, uv) {\n            if (position === void 0) { position = Vector3.Zero(); }\n            if (normal === void 0) { normal = Vector3.Up(); }\n            if (uv === void 0) { uv = Vector2.Zero(); }\n            this.position = position;\n            this.normal = normal;\n            this.uv = uv;\n        }\n        PositionNormalTextureVertex.prototype.clone = function () {\n            return new PositionNormalTextureVertex(this.position.clone(), this.normal.clone(), this.uv.clone());\n        };\n        return PositionNormalTextureVertex;\n    })();\n    BABYLON.PositionNormalTextureVertex = PositionNormalTextureVertex;\n    \/\/ SIMD\n    var previousMultiplyToArray = Matrix.prototype.multiplyToArray;\n    var previousInvertToRef = Matrix.prototype.invertToRef;\n    var previousLookAtLHToRef = Matrix.LookAtLHToRef;\n    var previousTransformCoordinatesToRef = Vector3.TransformCoordinatesToRef;\n    var previousTransformCoordinatesFromFloatsToRef = Vector3.TransformCoordinatesFromFloatsToRef;\n    var SIMDHelper = (function () {\n        function SIMDHelper() {\n        }\n        Object.defineProperty(SIMDHelper, \"IsEnabled\", {\n            get: function () {\n                return SIMDHelper._isEnabled;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        SIMDHelper.DisableSIMD = function () {\n            \/\/ Replace functions\n            Matrix.prototype.multiplyToArray = previousMultiplyToArray;\n            Matrix.prototype.invertToRef = previousInvertToRef;\n            Matrix.LookAtLHToRef = previousLookAtLHToRef;\n            Vector3.TransformCoordinatesToRef = previousTransformCoordinatesToRef;\n            Vector3.TransformCoordinatesFromFloatsToRef = previousTransformCoordinatesFromFloatsToRef;\n            SIMDHelper._isEnabled = false;\n        };\n        SIMDHelper.EnableSIMD = function () {\n            if (window.SIMD === undefined) {\n                return;\n            }\n            \/\/ Replace functions\n            Matrix.prototype.multiplyToArray = Matrix.prototype.multiplyToArraySIMD;\n            Matrix.prototype.invertToRef = Matrix.prototype.invertToRefSIMD;\n            Matrix.LookAtLHToRef = Matrix.LookAtLHToRefSIMD;\n            Vector3.TransformCoordinatesToRef = Vector3.TransformCoordinatesToRefSIMD;\n            Vector3.TransformCoordinatesFromFloatsToRef = Vector3.TransformCoordinatesFromFloatsToRefSIMD;\n            Object.defineProperty(BABYLON.Vector3.prototype, \"x\", {\n                get: function () {\n                    return this._data[0];\n                },\n                set: function (value) {\n                    if (!this._data) {\n                        this._data = new Float32Array(3);\n                    }\n                    this._data[0] = value;\n                }\n            });\n            Object.defineProperty(BABYLON.Vector3.prototype, \"y\", {\n                get: function () {\n                    return this._data[1];\n                },\n                set: function (value) {\n                    this._data[1] = value;\n                }\n            });\n            Object.defineProperty(BABYLON.Vector3.prototype, \"z\", {\n                get: function () {\n                    return this._data[2];\n                },\n                set: function (value) {\n                    this._data[2] = value;\n                }\n            });\n            SIMDHelper._isEnabled = true;\n        };\n        SIMDHelper._isEnabled = false;\n        return SIMDHelper;\n    })();\n    BABYLON.SIMDHelper = SIMDHelper;\n    if (window.SIMD !== undefined) {\n        SIMDHelper.EnableSIMD();\n    }\n})(BABYLON || (BABYLON = {}));';

    export interface ICollisionCoordinator {
        getNewPosition(position: Vector3, velocity: Vector3, collider: Collider, maximumRetry: number, excludedMesh: AbstractMesh, onNewPosition: (collisionIndex: number, newPosition: BABYLON.Vector3, collidedMesh?: BABYLON.AbstractMesh) => void, collisionIndex: number): void;
        init(scene: Scene): void;
        destroy(): void;

        //Update meshes and geometries
        onMeshAdded(mesh: AbstractMesh);
        onMeshUpdated(mesh: AbstractMesh);
        onMeshRemoved(mesh: AbstractMesh);
        onGeometryAdded(geometry: Geometry);
        onGeometryUpdated(geometry: Geometry);
        onGeometryDeleted(geometry: Geometry);
    }

    export interface SerializedMesh {
        id: string;
        name: string;
        uniqueId: number;
        geometryId: string;
        sphereCenter: Array<number>;
        sphereRadius: number;
        boxMinimum: Array<number>;
        boxMaximum: Array<number>;
        worldMatrixFromCache: any;
        subMeshes: Array<SerializedSubMesh>;
        checkCollisions: boolean;
    }

    export interface SerializedSubMesh {
        position: number;
        verticesStart: number;
        verticesCount: number;
        indexStart: number;
        indexCount: number;
        hasMaterial: boolean;
    }

    export interface SerializedGeometry {
        id: string;
        positions: Float32Array;
        indices: Int32Array;
        normals: Float32Array;
        //uvs?: Float32Array;
    }

    export interface BabylonMessage {
        taskType: WorkerTaskType;
        payload: InitPayload|CollidePayload|UpdatePayload /*any for TS under 1.4*/;
    }

    export interface SerializedColliderToWorker {
        position: Array<number>;
        velocity: Array<number>;
        radius: Array<number>;
    }

    export enum WorkerTaskType {
        INIT,
        UPDATE,
        COLLIDE
    }

    export interface WorkerReply {
        error: WorkerReplyType;
        taskType: WorkerTaskType;
        payload?: any;
    }

    export interface CollisionReplyPayload {
        newPosition: Array<number>;
        collisionId: number;
        collidedMeshUniqueId: number;
    }

    export interface InitPayload {

    }
    
    export interface CollidePayload {
        collisionId: number;
        collider: SerializedColliderToWorker;
        maximumRetry: number;
        excludedMeshUniqueId?: number;
    }
        
    export interface UpdatePayload {
        updatedMeshes: { [n: number]: SerializedMesh; };
        updatedGeometries: { [s: string]: SerializedGeometry; };
        removedMeshes: Array<number>;
        removedGeometries: Array<string>;
    }
    
    export enum WorkerReplyType {
        SUCCESS,
        UNKNOWN_ERROR
    }

    export class CollisionCoordinatorWorker implements ICollisionCoordinator {

        private _scene: Scene;

        private _scaledPosition = Vector3.Zero();
        private _scaledVelocity = Vector3.Zero();

        private _collisionsCallbackArray: Array<(collisionIndex: number, newPosition: BABYLON.Vector3, collidedMesh?: BABYLON.AbstractMesh) => void>;

        private _init: boolean;
        private _runningUpdated: number;
        private _runningCollisionTask: boolean;
        private _worker: Worker;

        private _addUpdateMeshesList: { [n: number]: SerializedMesh; }
        private _addUpdateGeometriesList: { [s: string]: SerializedGeometry; };
        private _toRemoveMeshesArray: Array<number>;
        private _toRemoveGeometryArray: Array<string>;

        constructor() {
            this._collisionsCallbackArray = [];
            this._init = false;
            this._runningUpdated = 0;
            this._runningCollisionTask = false;

            this._addUpdateMeshesList = {};
            this._addUpdateGeometriesList = {};
            this._toRemoveGeometryArray = [];
            this._toRemoveMeshesArray = [];
        }

        public static SerializeMesh = function (mesh: BABYLON.AbstractMesh): SerializedMesh {
            var submeshes : Array<SerializedSubMesh> = [];
            if (mesh.subMeshes) {
                submeshes = mesh.subMeshes.map(function (sm, idx) {
                    return {
                        position: idx,
                        verticesStart: sm.verticesStart,
                        verticesCount: sm.verticesCount,
                        indexStart: sm.indexStart,
                        indexCount: sm.indexCount,
                        hasMaterial: !!sm.getMaterial()
                    }
                });
            }

            var geometryId = (<BABYLON.Mesh>mesh).geometry ? (<BABYLON.Mesh>mesh).geometry.id : null;

            return {
                uniqueId: mesh.uniqueId,
                id: mesh.id,
                name: mesh.name,
                geometryId: geometryId,
                sphereCenter: mesh.getBoundingInfo().boundingSphere.centerWorld.asArray(),
                sphereRadius: mesh.getBoundingInfo().boundingSphere.radiusWorld,
                boxMinimum: mesh.getBoundingInfo().boundingBox.minimumWorld.asArray(),
                boxMaximum: mesh.getBoundingInfo().boundingBox.maximumWorld.asArray(),
                worldMatrixFromCache: mesh.worldMatrixFromCache.asArray(),
                subMeshes: submeshes,
                checkCollisions: mesh.checkCollisions
            }
        }

        public static SerializeGeometry = function (geometry: BABYLON.Geometry): SerializedGeometry {
            return {
                id: geometry.id,
                positions: new Float32Array(geometry.getVerticesData(BABYLON.VertexBuffer.PositionKind) || []),
                normals: new Float32Array(geometry.getVerticesData(BABYLON.VertexBuffer.NormalKind) || []),
                indices: new Int32Array(geometry.getIndices() || []),
                //uvs: new Float32Array(geometry.getVerticesData(BABYLON.VertexBuffer.UVKind) || [])
            }
        }

        public getNewPosition(position: Vector3, velocity: Vector3, collider: Collider, maximumRetry: number, excludedMesh: AbstractMesh, onNewPosition: (collisionIndex: number, newPosition: BABYLON.Vector3, collidedMesh?: BABYLON.AbstractMesh) => void, collisionIndex: number): void {
            if (!this._init);
            if (this._collisionsCallbackArray[collisionIndex]) return;

            position.divideToRef(collider.radius, this._scaledPosition);
            velocity.divideToRef(collider.radius, this._scaledVelocity);

            this._collisionsCallbackArray[collisionIndex] = onNewPosition;

            var payload: CollidePayload = {
                collider: {
                    position: this._scaledPosition.asArray(),
                    velocity: this._scaledVelocity.asArray(),
                    radius: collider.radius.asArray()
                },
                collisionId: collisionIndex,
                excludedMeshUniqueId: excludedMesh ? excludedMesh.uniqueId : null,
                maximumRetry: maximumRetry
            };
            var message: BabylonMessage = {
                payload: payload,
                taskType: WorkerTaskType.COLLIDE
            }
            //console.time("webworker");
            this._worker.postMessage(message);

        }

        public init(scene: Scene): void {
            this._scene = scene;
            this._scene.registerAfterRender(this._afterRender);
            var blobURL = URL.createObjectURL(new Blob(['(function(){', BABYLON.CollisionWorker, '})()'], { type: 'application/javascript' }));
            this._worker = new Worker(blobURL);
            this._worker.onmessage = this._onMessageFromWorker;
            URL.revokeObjectURL(blobURL);
            var message: BabylonMessage = {
                payload: {},
                taskType: WorkerTaskType.INIT
            }
            this._worker.postMessage(message);
        }

        public destroy(): void {
            this._scene.unregisterAfterRender(this._afterRender);
            this._worker.terminate();
        }

        public onMeshAdded(mesh: AbstractMesh) {
            mesh.registerAfterWorldMatrixUpdate(this.onMeshUpdated);
            this.onMeshUpdated(mesh);
        }

        public onMeshUpdated = (mesh: AbstractMesh) => {
            this._addUpdateMeshesList[mesh.uniqueId] = CollisionCoordinatorWorker.SerializeMesh(mesh);
        }

        public onMeshRemoved(mesh: AbstractMesh) {
            this._toRemoveMeshesArray.push(mesh.uniqueId);
        }

        public onGeometryAdded(geometry: Geometry) {
            //TODO this will break if the user uses his own function. This should be an array of callbacks!
            geometry.onGeometryUpdated = this.onGeometryUpdated;
            this.onGeometryUpdated(geometry);
        }

        public onGeometryUpdated = (geometry: Geometry) => {
            this._addUpdateGeometriesList[geometry.id] = CollisionCoordinatorWorker.SerializeGeometry(geometry);
        }

        public onGeometryDeleted(geometry: Geometry) {
            this._toRemoveGeometryArray.push(geometry.id);
        }

        private _afterRender = () => {

            if (!this._init) return;

            if (this._toRemoveGeometryArray.length == 0 && this._toRemoveMeshesArray.length == 0 && Object.keys(this._addUpdateGeometriesList).length == 0 && Object.keys(this._addUpdateMeshesList).length == 0) {
                return;
            }

            var payload: UpdatePayload = {
                updatedMeshes: this._addUpdateMeshesList,
                updatedGeometries: this._addUpdateGeometriesList,
                removedGeometries: this._toRemoveGeometryArray,
                removedMeshes: this._toRemoveMeshesArray
            };
            var message: BabylonMessage = {
                payload: payload,
                taskType: WorkerTaskType.UPDATE
            }
            var serializable = [];
            for (var id in payload.updatedGeometries) {
                if (payload.updatedGeometries.hasOwnProperty(id)) {
                    //prepare transferables
                    serializable.push((<UpdatePayload> message.payload).updatedGeometries[id].indices.buffer);
                    serializable.push((<UpdatePayload> message.payload).updatedGeometries[id].normals.buffer);
                    serializable.push((<UpdatePayload> message.payload).updatedGeometries[id].positions.buffer);
                }
            }
            //this variable is here only in case the update takes longer than a frame! 
            this._runningUpdated++;

            this._worker.postMessage(message, serializable);
            this._addUpdateMeshesList = {};
            this._addUpdateGeometriesList = {};
            this._toRemoveGeometryArray = [];
            this._toRemoveMeshesArray = [];
        }

        private _onMessageFromWorker = (e: MessageEvent) => {
            var returnData = <WorkerReply> e.data;
            if (returnData.error != WorkerReplyType.SUCCESS) {
                //TODO what errors can be returned from the worker?
                Tools.Warn("error returned from worker!");
                return;
            }

            switch (returnData.taskType) {
                case WorkerTaskType.INIT:
                    //TODO is init required after worker is done initializing?
                    this._init = true;
                    break;
                case WorkerTaskType.UPDATE:
                    this._runningUpdated--;
                    break;
                case WorkerTaskType.COLLIDE:
                    this._runningCollisionTask = false;
                    var returnPayload: CollisionReplyPayload = returnData.payload;
                    if (!this._collisionsCallbackArray[returnPayload.collisionId]) return;

                    this._collisionsCallbackArray[returnPayload.collisionId](returnPayload.collisionId, Vector3.FromArray(returnPayload.newPosition), this._scene.getMeshByUniqueID(returnPayload.collidedMeshUniqueId));
                    //cleanup
                    this._collisionsCallbackArray[returnPayload.collisionId] = undefined;
                    break;
            }
        }
    }

    export class CollisionCoordinatorLegacy implements ICollisionCoordinator {

        private _scene: Scene;

        private _scaledPosition = Vector3.Zero();
        private _scaledVelocity = Vector3.Zero();

        private _finalPosition = Vector3.Zero();

        public getNewPosition(position: Vector3, velocity: Vector3, collider: Collider, maximumRetry: number, excludedMesh: AbstractMesh, onNewPosition: (collisionIndex: number, newPosition: BABYLON.Vector3, collidedMesh?: BABYLON.AbstractMesh) => void, collisionIndex: number): void {
            position.divideToRef(collider.radius, this._scaledPosition);
            velocity.divideToRef(collider.radius, this._scaledVelocity);
            
            collider.retry = 0;
            collider.initialVelocity = this._scaledVelocity;
            collider.initialPosition = this._scaledPosition;
            this._collideWithWorld(this._scaledPosition, this._scaledVelocity, collider, maximumRetry, this._finalPosition, excludedMesh);

            this._finalPosition.multiplyInPlace(collider.radius);
            //run the callback
            onNewPosition(null, this._finalPosition, collider.collidedMesh);
        }

        public init(scene: Scene): void {
            this._scene = scene;
        }

        public destroy(): void {
            //Legacy need no destruction method.
        }

        //No update in legacy mode
        public onMeshAdded(mesh: AbstractMesh) { }
        public onMeshUpdated(mesh: AbstractMesh) { }
        public onMeshRemoved(mesh: AbstractMesh) { }
        public onGeometryAdded(geometry: Geometry) { }
        public onGeometryUpdated(geometry: Geometry) { }
        public onGeometryDeleted(geometry: Geometry) { }

        private _collideWithWorld(position: Vector3, velocity: Vector3, collider: Collider, maximumRetry: number, finalPosition: Vector3, excludedMesh: AbstractMesh = null): void {
            var closeDistance = Engine.CollisionsEpsilon * 10.0;

            if (collider.retry >= maximumRetry) {
                finalPosition.copyFrom(position);
                return;
            }

            collider._initialize(position, velocity, closeDistance);

            // Check all meshes
            for (var index = 0; index < this._scene.meshes.length; index++) {
                var mesh = this._scene.meshes[index];
                if (mesh.isEnabled() && mesh.checkCollisions && mesh.subMeshes && mesh !== excludedMesh) {
                    mesh._checkCollision(collider);
                }
            }

            if (!collider.collisionFound) {
                position.addToRef(velocity, finalPosition);
                return;
            }

            if (velocity.x !== 0 || velocity.y !== 0 || velocity.z !== 0) {
                collider._getResponse(position, velocity);
            }

            if (velocity.length() <= closeDistance) {
                finalPosition.copyFrom(position);
                return;
            }

            collider.retry++;
            this._collideWithWorld(position, velocity, collider, maximumRetry, finalPosition, excludedMesh);
        }
    }
}