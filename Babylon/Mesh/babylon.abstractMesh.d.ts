declare module BABYLON {
    class AbstractMesh extends Node implements IDisposable {
        private static _BILLBOARDMODE_NONE;
        private static _BILLBOARDMODE_X;
        private static _BILLBOARDMODE_Y;
        private static _BILLBOARDMODE_Z;
        private static _BILLBOARDMODE_ALL;
        static BILLBOARDMODE_NONE : number;
        static BILLBOARDMODE_X : number;
        static BILLBOARDMODE_Y : number;
        static BILLBOARDMODE_Z : number;
        static BILLBOARDMODE_ALL : number;
        public position: Vector3;
        public rotation: Vector3;
        public rotationQuaternion: Quaternion;
        public scaling: Vector3;
        public billboardMode: number;
        public visibility: number;
        public alphaIndex: number;
        public infiniteDistance: boolean;
        public isVisible: boolean;
        public isPickable: boolean;
        public showBoundingBox: boolean;
        public showSubMeshesBoundingBox: boolean;
        public onDispose: any;
        public checkCollisions: boolean;
        public isBlocker: boolean;
        public skeleton: Skeleton;
        public renderingGroupId: number;
        public material: Material;
        public receiveShadows: boolean;
        public actionManager: ActionManager;
        public renderOutline: boolean;
        public outlineColor: Color3;
        public outlineWidth: number;
        public renderOverlay: boolean;
        public overlayColor: Color3;
        public overlayAlpha: number;
        public hasVertexAlpha: boolean;
        public useVertexColors: boolean;
        public applyFog: boolean;
        public useOctreeForRenderingSelection: boolean;
        public useOctreeForPicking: boolean;
        public useOctreeForCollisions: boolean;
        public layerMask: number;
        public _physicImpostor: number;
        public _physicsMass: number;
        public _physicsFriction: number;
        public _physicRestitution: number;
        public ellipsoid: Vector3;
        public ellipsoidOffset: Vector3;
        private _collider;
        private _oldPositionForCollisions;
        private _diffPositionForCollisions;
        private _newPositionForCollisions;
        private _localScaling;
        private _localRotation;
        private _localTranslation;
        private _localBillboard;
        private _localPivotScaling;
        private _localPivotScalingRotation;
        private _localWorld;
        public _worldMatrix: Matrix;
        private _rotateYByPI;
        private _absolutePosition;
        private _collisionsTransformMatrix;
        private _collisionsScalingMatrix;
        public _positions: Vector3[];
        private _isDirty;
        public _masterMesh: AbstractMesh;
        public _boundingInfo: BoundingInfo;
        private _pivotMatrix;
        public _isDisposed: boolean;
        public _renderId: number;
        public subMeshes: SubMesh[];
        public _submeshesOctree: Octree<SubMesh>;
        public _intersectionsInProgress: AbstractMesh[];
        private _onAfterWorldMatrixUpdate;
        constructor(name: string, scene: Scene);
        public isBlocked : boolean;
        public getLOD(camera: Camera): AbstractMesh;
        public getTotalVertices(): number;
        public getIndices(): number[];
        public getVerticesData(kind: string): number[];
        public isVerticesDataPresent(kind: string): boolean;
        public getBoundingInfo(): BoundingInfo;
        public _preActivate(): void;
        public _activate(renderId: number): void;
        public getWorldMatrix(): Matrix;
        public worldMatrixFromCache : Matrix;
        public absolutePosition : Vector3;
        public rotate(axis: Vector3, amount: number, space: Space): void;
        public translate(axis: Vector3, distance: number, space: Space): void;
        public getAbsolutePosition(): Vector3;
        public setAbsolutePosition(absolutePosition: Vector3): void;
        public setPivotMatrix(matrix: Matrix): void;
        public getPivotMatrix(): Matrix;
        public _isSynchronized(): boolean;
        public _initCache(): void;
        public markAsDirty(property: string): void;
        public _updateBoundingInfo(): void;
        public _updateSubMeshesBoundingInfo(matrix: Matrix): void;
        public computeWorldMatrix(force?: boolean): Matrix;
        /**
        * If you'd like to be callbacked after the mesh position, rotation or scaling has been updated
        * @param func: callback function to add
        */
        public registerAfterWorldMatrixUpdate(func: (mesh: AbstractMesh) => void): void;
        public unregisterAfterWorldMatrixUpdate(func: (mesh: AbstractMesh) => void): void;
        public setPositionWithLocalVector(vector3: Vector3): void;
        public getPositionExpressedInLocalSpace(): Vector3;
        public locallyTranslate(vector3: Vector3): void;
        public lookAt(targetPoint: Vector3, yawCor: number, pitchCor: number, rollCor: number): void;
        public isInFrustum(frustumPlanes: Plane[]): boolean;
        public isCompletelyInFrustum(camera?: Camera): boolean;
        public intersectsMesh(mesh: AbstractMesh, precise?: boolean): boolean;
        public intersectsPoint(point: Vector3): boolean;
        public setPhysicsState(impostor?: any, options?: PhysicsBodyCreationOptions): any;
        public getPhysicsImpostor(): number;
        public getPhysicsMass(): number;
        public getPhysicsFriction(): number;
        public getPhysicsRestitution(): number;
        public getPositionInCameraSpace(camera?: Camera): Vector3;
        public getDistanceToCamera(camera?: Camera): number;
        public applyImpulse(force: Vector3, contactPoint: Vector3): void;
        public setPhysicsLinkWith(otherMesh: Mesh, pivot1: Vector3, pivot2: Vector3, options?: any): void;
        public updatePhysicsBodyPosition(): void;
        public moveWithCollisions(velocity: Vector3): void;
        /**
        * This function will create an octree to help select the right submeshes for rendering, picking and collisions
        * Please note that you must have a decent number of submeshes to get performance improvements when using octree
        */
        public createOrUpdateSubmeshesOctree(maxCapacity?: number, maxDepth?: number): Octree<SubMesh>;
        public _collideForSubMesh(subMesh: SubMesh, transformMatrix: Matrix, collider: Collider): void;
        public _processCollisionsForSubMeshes(collider: Collider, transformMatrix: Matrix): void;
        public _checkCollision(collider: Collider): void;
        public _generatePointsArray(): boolean;
        public intersects(ray: Ray, fastCheck?: boolean): PickingInfo;
        public clone(name: string, newParent: Node, doNotCloneChildren?: boolean): AbstractMesh;
        public releaseSubMeshes(): void;
        public dispose(doNotRecurse?: boolean): void;
    }
}
