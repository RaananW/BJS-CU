declare module BABYLON {
    class _DepthCullingState {
        private _isDepthTestDirty;
        private _isDepthMaskDirty;
        private _isDepthFuncDirty;
        private _isCullFaceDirty;
        private _isCullDirty;
        private _depthTest;
        private _depthMask;
        private _depthFunc;
        private _cull;
        private _cullFace;
        public isDirty : boolean;
        public cullFace : number;
        public cull : boolean;
        public depthFunc : number;
        public depthMask : boolean;
        public depthTest : boolean;
        public reset(): void;
        public apply(gl: WebGLRenderingContext): void;
    }
    class _AlphaState {
        private _isAlphaBlendDirty;
        private _isBlendFunctionParametersDirty;
        private _alphaBlend;
        private _blendFunctionParameters;
        public isDirty : boolean;
        public alphaBlend : boolean;
        public setAlphaBlendFunctionParameters(value0: number, value1: number, value2: number, value3: number): void;
        public reset(): void;
        public apply(gl: WebGLRenderingContext): void;
    }
    class EngineCapabilities {
        public maxTexturesImageUnits: number;
        public maxTextureSize: number;
        public maxCubemapTextureSize: number;
        public maxRenderTextureSize: number;
        public standardDerivatives: boolean;
        public s3tc: any;
        public textureFloat: boolean;
        public textureAnisotropicFilterExtension: any;
        public maxAnisotropy: number;
        public instancedArrays: any;
        public uintIndices: boolean;
    }
    class Engine {
        private static _ALPHA_DISABLE;
        private static _ALPHA_ADD;
        private static _ALPHA_COMBINE;
        private static _DELAYLOADSTATE_NONE;
        private static _DELAYLOADSTATE_LOADED;
        private static _DELAYLOADSTATE_LOADING;
        private static _DELAYLOADSTATE_NOTLOADED;
        private static _TEXTUREFORMAT_ALPHA;
        private static _TEXTUREFORMAT_LUMINANCE;
        private static _TEXTUREFORMAT_LUMINANCE_ALPHA;
        private static _TEXTUREFORMAT_RGB;
        private static _TEXTUREFORMAT_RGBA;
        static ALPHA_DISABLE : number;
        static ALPHA_ADD : number;
        static ALPHA_COMBINE : number;
        static DELAYLOADSTATE_NONE : number;
        static DELAYLOADSTATE_LOADED : number;
        static DELAYLOADSTATE_LOADING : number;
        static DELAYLOADSTATE_NOTLOADED : number;
        static TEXTUREFORMAT_ALPHA : number;
        static TEXTUREFORMAT_LUMINANCE : number;
        static TEXTUREFORMAT_LUMINANCE_ALPHA : number;
        static TEXTUREFORMAT_RGB : number;
        static TEXTUREFORMAT_RGBA : number;
        static Version : string;
        static Epsilon: number;
        static CollisionsEpsilon: number;
        static ShadersRepository: string;
        public isFullscreen: boolean;
        public isPointerLock: boolean;
        public cullBackFaces: boolean;
        public renderEvenInBackground: boolean;
        public scenes: Scene[];
        private _gl;
        private _renderingCanvas;
        private _windowIsBackground;
        private _audioEngine;
        private _onBlur;
        private _onFocus;
        private _onFullscreenChange;
        private _onPointerLockChange;
        private _hardwareScalingLevel;
        private _caps;
        private _pointerLockRequested;
        private _alphaTest;
        private _resizeLoadingUI;
        private _loadingDiv;
        private _loadingTextDiv;
        private _loadingDivBackgroundColor;
        private _drawCalls;
        private _renderingQueueLaunched;
        private _activeRenderLoops;
        private fpsRange;
        private previousFramesDuration;
        private fps;
        private deltaTime;
        private _depthCullingState;
        private _alphaState;
        private _alphaMode;
        private _loadedTexturesCache;
        public _activeTexturesCache: BaseTexture[];
        private _currentEffect;
        private _compiledEffects;
        private _vertexAttribArrays;
        private _cachedViewport;
        private _cachedVertexBuffers;
        private _cachedIndexBuffer;
        private _cachedEffectForVertexBuffers;
        private _currentRenderTarget;
        private _canvasClientRect;
        private _uintIndicesCurrentlySet;
        private _workingCanvas;
        private _workingContext;
        constructor(canvas: HTMLCanvasElement, antialias?: boolean, options?: any);
        public getAudioEngine(): AudioEngine;
        public getAspectRatio(camera: Camera): number;
        public getRenderWidth(): number;
        public getRenderHeight(): number;
        public getRenderingCanvas(): HTMLCanvasElement;
        public getRenderingCanvasClientRect(): ClientRect;
        public setHardwareScalingLevel(level: number): void;
        public getHardwareScalingLevel(): number;
        public getLoadedTexturesCache(): WebGLTexture[];
        public getCaps(): EngineCapabilities;
        public drawCalls : number;
        public resetDrawCalls(): void;
        public setDepthFunctionToGreater(): void;
        public setDepthFunctionToGreaterOrEqual(): void;
        public setDepthFunctionToLess(): void;
        public setDepthFunctionToLessOrEqual(): void;
        public stopRenderLoop(renderFunction?: () => void): void;
        public _renderLoop(): void;
        public runRenderLoop(renderFunction: () => void): void;
        public switchFullscreen(requestPointerLock: boolean): void;
        public clear(color: any, backBuffer: boolean, depthStencil: boolean): void;
        public setViewport(viewport: Viewport, requiredWidth?: number, requiredHeight?: number): void;
        public setDirectViewport(x: number, y: number, width: number, height: number): void;
        public beginFrame(): void;
        public endFrame(): void;
        public resize(): void;
        public setSize(width: number, height: number): void;
        public bindFramebuffer(texture: WebGLTexture): void;
        public unBindFramebuffer(texture: WebGLTexture): void;
        public flushFramebuffer(): void;
        public restoreDefaultFramebuffer(): void;
        private _resetVertexBufferBinding();
        public createVertexBuffer(vertices: number[]): WebGLBuffer;
        public createDynamicVertexBuffer(capacity: number): WebGLBuffer;
        public updateDynamicVertexBuffer(vertexBuffer: WebGLBuffer, vertices: any, offset?: number): void;
        private _resetIndexBufferBinding();
        public createIndexBuffer(indices: number[]): WebGLBuffer;
        public bindBuffers(vertexBuffer: WebGLBuffer, indexBuffer: WebGLBuffer, vertexDeclaration: number[], vertexStrideSize: number, effect: Effect): void;
        public bindMultiBuffers(vertexBuffers: VertexBuffer[], indexBuffer: WebGLBuffer, effect: Effect): void;
        public _releaseBuffer(buffer: WebGLBuffer): boolean;
        public createInstancesBuffer(capacity: number): WebGLBuffer;
        public deleteInstancesBuffer(buffer: WebGLBuffer): void;
        public updateAndBindInstancesBuffer(instancesBuffer: WebGLBuffer, data: Float32Array, offsetLocations: number[]): void;
        public unBindInstancesBuffer(instancesBuffer: WebGLBuffer, offsetLocations: number[]): void;
        public applyStates(): void;
        public draw(useTriangles: boolean, indexStart: number, indexCount: number, instancesCount?: number): void;
        public drawPointClouds(verticesStart: number, verticesCount: number, instancesCount?: number): void;
        public _releaseEffect(effect: Effect): void;
        public createEffect(baseName: any, attributesNames: string[], uniformsNames: string[], samplers: string[], defines: string, fallbacks?: EffectFallbacks, onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void): Effect;
        public createEffectForParticles(fragmentName: string, uniformsNames?: string[], samplers?: string[], defines?: string, fallbacks?: EffectFallbacks, onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void): Effect;
        public createShaderProgram(vertexCode: string, fragmentCode: string, defines: string): WebGLProgram;
        public getUniforms(shaderProgram: WebGLProgram, uniformsNames: string[]): WebGLUniformLocation[];
        public getAttributes(shaderProgram: WebGLProgram, attributesNames: string[]): number[];
        public enableEffect(effect: Effect): void;
        public setArray(uniform: WebGLUniformLocation, array: number[]): void;
        public setMatrices(uniform: WebGLUniformLocation, matrices: Float32Array): void;
        public setMatrix(uniform: WebGLUniformLocation, matrix: Matrix): void;
        public setFloat(uniform: WebGLUniformLocation, value: number): void;
        public setFloat2(uniform: WebGLUniformLocation, x: number, y: number): void;
        public setFloat3(uniform: WebGLUniformLocation, x: number, y: number, z: number): void;
        public setBool(uniform: WebGLUniformLocation, bool: number): void;
        public setFloat4(uniform: WebGLUniformLocation, x: number, y: number, z: number, w: number): void;
        public setColor3(uniform: WebGLUniformLocation, color3: Color3): void;
        public setColor4(uniform: WebGLUniformLocation, color3: Color3, alpha: number): void;
        public setState(culling: boolean, force?: boolean): void;
        public setDepthBuffer(enable: boolean): void;
        public getDepthWrite(): boolean;
        public setDepthWrite(enable: boolean): void;
        public setColorWrite(enable: boolean): void;
        public setAlphaMode(mode: number): void;
        public getAlphaMode(): number;
        public setAlphaTesting(enable: boolean): void;
        public getAlphaTesting(): boolean;
        public wipeCaches(): void;
        public setSamplingMode(texture: WebGLTexture, samplingMode: number): void;
        public createTexture(url: string, noMipmap: boolean, invertY: boolean, scene: Scene, samplingMode?: number, onLoad?: () => void, onError?: () => void, buffer?: any): WebGLTexture;
        public createRawTexture(data: ArrayBufferView, width: number, height: number, format: number, generateMipMaps: boolean, invertY: boolean, samplingMode: number): WebGLTexture;
        public createDynamicTexture(width: number, height: number, generateMipMaps: boolean, samplingMode: number): WebGLTexture;
        public updateDynamicTexture(texture: WebGLTexture, canvas: HTMLCanvasElement, invertY: boolean): void;
        public updateVideoTexture(texture: WebGLTexture, video: HTMLVideoElement, invertY: boolean): void;
        public createRenderTargetTexture(size: any, options: any): WebGLTexture;
        public createCubeTexture(rootUrl: string, scene: Scene, extensions: string[], noMipmap?: boolean): WebGLTexture;
        public _releaseTexture(texture: WebGLTexture): void;
        public bindSamplers(effect: Effect): void;
        public _bindTexture(channel: number, texture: WebGLTexture): void;
        public setTextureFromPostProcess(channel: number, postProcess: PostProcess): void;
        public setTexture(channel: number, texture: BaseTexture): void;
        public _setAnisotropicLevel(key: number, texture: BaseTexture): void;
        public readPixels(x: number, y: number, width: number, height: number): Uint8Array;
        public dispose(): void;
        public displayLoadingUI(): void;
        public loadingUIText : string;
        public loadingUIBackgroundColor : string;
        public hideLoadingUI(): void;
        public getFps(): number;
        public getDeltaTime(): number;
        private _measureFps();
        static isSupported(): boolean;
    }
}
